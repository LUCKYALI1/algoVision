const dsaData = {
    "Array": {
        "topicName": "Array",
        "theoryAndFeatures": "An **Array** is a fundamental linear data structure that stores a collection of elements of the **same data type** in **contiguous memory locations**. Each element is identified by an index, typically a zero-based integer. This contiguous storage is the array's most defining feature, allowing for highly efficient access to any element by calculating its memory address.\n\n### Key Features:\n- **Contiguous Memory:** Elements are stored side-by-side, which is excellent for CPU cache performance.\n- **Random Access:** Any element can be accessed directly using its index in constant time.\n- **Fixed Size (Static Arrays):** In languages like C++ and Java, the size of an array is fixed upon creation.\n- **Dynamic Size (Dynamic Arrays):** Data structures like C++'s `std::vector` or Python's `list` are built on top of arrays but can automatically resize themselves. This resizing operation, however, can be costly (O(n)).\n\n### Complexity Analysis:\n| Operation          | Average Case | Worst Case   | Explanation                                                              |\n| ------------------ | ------------ | ------------ | ------------------------------------------------------------------------ |\n| Access (by index)  | O(1)         | O(1)         | The memory address is calculated directly from the index.                |\n| Search (linear)    | O(n)         | O(n)         | Must potentially check every element.                                    |\n| Insertion (at end) | O(1)* | O(n)* | *Amortized O(1) for dynamic arrays, but O(n) if resizing is needed.    |\n| Insertion (middle) | O(n)         | O(n)         | All subsequent elements must be shifted.                                 |\n| Deletion (at end)  | O(1)         | O(1)         | No shifting of elements is required.                                     |\n| Deletion (middle)  | O(n)         | O(n)         | All subsequent elements must be shifted to fill the gap.                 |",
        "realWorldAnalogy": "Think of an **egg carton** 🥚. It has a fixed number of slots (its size), and each slot is in a specific, numbered position (the index). You can instantly access the 5th slot to get an egg (random access). If you want to add an egg to a full carton, you need a new, bigger carton and have to move all the eggs over (resizing).",
        "advancedTopics": "- **Dynamic Arrays (Vectors):** Automatically handle resizing, providing more flexibility than static arrays.\n- **Multi-dimensional Arrays:** Arrays of arrays, used to represent matrices or grids (e.g., for game boards or image pixels).\n- **Prefix Sum Array:** A precomputed array where `prefix[i]` stores the sum of all elements from index `0` to `i`. Allows for O(1) range sum queries.\n- **Sliding Window:** A technique that uses a conceptual window that slides over an array, often used to solve subarray problems efficiently.",
        "codingProblems": [
            {
                "title": "Two Sum",
                "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/two-sum/",
                    "gfg": "https://www.geeksforgeeks.org/problems/two-sum-1587115621/1"
                },
                "pattern": "Using a hash map for efficient lookups to find the complement.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    std::vector<int> twoSum(std::vector<int>& nums, int target) {\n        std::unordered_map<int, int> numMap;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (numMap.count(complement)) {\n                return {numMap[complement], i};\n            }\n            numMap[nums[i]] = i;\n        }\n        return {}; // Should not happen based on problem constraints\n    }\n}; \n```",
                    "python": "```python\nclass Solution:\n    def twoSum(self, nums: list[int], target: int) -> list[int]:\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n        return []\n```",
                    "javascript": "```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const numMap = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (numMap.has(complement)) {\n            return [numMap.get(complement), i];\n        }\n        numMap.set(nums[i], i);\n    }\n    return [];\n};\n```"
                }
            },
            {
                "title": "Container With Most Water",
                "description": "Given an array of non-negative integers representing heights, find two lines that together with the x-axis form a container, such that the container contains the most water.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/container-with-most-water/",
                    "gfg": "https://www.geeksforgeeks.org/problems/container-with-most-water0535/1"
                },
                "pattern": "Two Pointers, moving the pointer with the shorter line inward.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int maxArea(std::vector<int>& height) {\n        int left = 0;\n        int right = height.size() - 1;\n        int max_area = 0;\n        while (left < right) {\n            int current_height = std::min(height[left], height[right]);\n            int current_width = right - left;\n            max_area = std::max(max_area, current_height * current_width);\n\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return max_area;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def maxArea(self, height: list[int]) -> int:\n        left, right = 0, len(height) - 1\n        max_area = 0\n        while left < right:\n            current_height = min(height[left], height[right])\n            current_width = right - left\n            max_area = max(max_area, current_height * current_width)\n\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area\n```",
                    "javascript": "```javascript\n/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function(height) {\n    let left = 0;\n    let right = height.length - 1;\n    let maxArea = 0;\n\n    while (left < right) {\n        const currentHeight = Math.min(height[left], height[right]);\n        const currentWidth = right - left;\n        maxArea = Math.max(maxArea, currentHeight * currentWidth);\n\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return maxArea;\n};\n```"
                }
            },
            {
                "title": "Trapping Rain Water",
                "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/trapping-rain-water/",
                    "gfg": "https://www.geeksforgeeks.org/problems/trapping-rain-water-1587115621/1"
                },
                "pattern": "Two Pointers (optimized), Dynamic Programming, or Monotonic Stack.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int trap(std::vector<int>& height) {\n        if (height.empty()) return 0;\n        int left = 0, right = height.size() - 1;\n        int left_max = 0, right_max = 0;\n        int water = 0;\n\n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= left_max) {\n                    left_max = height[left];\n                } else {\n                    water += left_max - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= right_max) {\n                    right_max = height[right];\n                } else {\n                    water += right_max - height[right];\n                }\n                right--;\n            }\n        }\n        return water;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def trap(self, height: list[int]) -> int:\n        if not height:\n            return 0\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = 0, 0\n        water = 0\n        \n        while left < right:\n            if height[left] < height[right]:\n                if height[left] >= left_max:\n                    left_max = height[left]\n                else:\n                    water += left_max - height[left]\n                left += 1\n            else:\n                if height[right] >= right_max:\n                    right_max = height[right]\n                else:\n                    water += right_max - height[right]\n                right -= 1\n        return water\n```",
                    "javascript": "```javascript\n/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function(height) {\n    if (!height || height.length === 0) return 0;\n\n    let left = 0, right = height.length - 1;\n    let leftMax = 0, rightMax = 0;\n    let water = 0;\n\n    while (left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] >= leftMax) {\n                leftMax = height[left];\n            } else {\n                water += leftMax - height[left];\n            }\n            left++;\n        } else {\n            if (height[right] >= rightMax) {\n                rightMax = height[right];\n            } else {\n                water += rightMax - height[right];\n            }\n            right--;\n        }\n    }\n    return water;\n};\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Arrays are the **most common** data structure in interviews. Questions range from easy to hard. Mastery is non-negotiable.\n\n### Tips:\n- **Clarify Constraints:** Ask if the array is sorted, contains duplicates, or has negative numbers. This can completely change the optimal approach.\n- **Think About Space-Time Tradeoffs:** Often, you can use extra space (like a hash map) to reduce time complexity. Be prepared to discuss this tradeoff.\n- **Master the Patterns:** Two Pointers, Sliding Window, and Prefix Sums are your best friends for array problems. Recognizing which pattern to use is a key skill."
    },
    "String": {
        "topicName": "String",
        "theoryAndFeatures": "A **String** is a data structure representing a **sequence of characters**. Internally, it's often implemented as an array of characters. A crucial property of strings in languages like Java, Python, and JavaScript is their **immutability** – once a string is created, it cannot be changed. Operations that seem to modify a string actually create a new one.\n\n### Key Features:\n- **Sequence of Characters:** Ordered collection of characters.\n- **Immutability (Commonly):** In many languages, strings are immutable. This makes them thread-safe and allows for internal optimizations. C++ `std::string` is a notable exception, as it's mutable.\n- **Rich API:** Most languages provide a vast library of functions for string manipulation (slicing, searching, concatenation, etc.).\n\n### Complexity Analysis:\n| Operation                 | Average Case | Worst Case   | Explanation                                                              |\n| ------------------------- | ------------ | ------------ | ------------------------------------------------------------------------ |\n| Access (by index)         | O(1)         | O(1)         | Similar to arrays.                                                       |\n| Search (substring)        | O(n*m)       | O(n*m)       | Naive search, where n and m are lengths of string and substring.         |\n| Concatenation             | O(n+m)       | O(n+m)       | A new string of combined length must be created.                         |\n| Slicing / Substring       | O(k)         | O(k)         | A new string of length k (the slice length) is created.                  |",
        "realWorldAnalogy": "Think of a word printed in a **book** 📖. The word 'hello' is fixed. You can't change the letter 'e' to 'a' directly on the page. To get 'hallo', you have to cross out 'hello' and write the new word 'hallo' elsewhere. This is like immutability – you create a new string instead of modifying the original.",
        "advancedTopics": "- **String Searching Algorithms:** Advanced algorithms like **KMP (Knuth-Morris-Pratt)** and **Rabin-Karp** can find substrings in O(n+m) time, which is much faster than the naive approach.\n- **Trie (Prefix Tree):** A special tree-like data structure used for efficient retrieval of keys in a dataset of strings.\n- **Suffix Trees & Suffix Arrays:** Powerful data structures used for complex string processing tasks like finding the longest repeated substring.",
        "codingProblems": [
            {
                "title": "Valid Anagram",
                "description": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/valid-anagram/",
                    "gfg": "https://www.geeksforgeeks.org/problems/anagram-1587115620/1"
                },
                "pattern": "Character Counting using a hash map or an integer array.",
                "solutions": {
                    "cpp": "```cpp\n#include <string>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    bool isAnagram(std::string s, std::string t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        std::unordered_map<char, int> counts;\n        for (char c : s) {\n            counts[c]++;\n        }\n        for (char c : t) {\n            if (counts.find(c) == counts.end() || counts[c] == 0) {\n                return false;\n            }\n            counts[c]--;\n        }\n        return true;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        counts = {}\n        for char in s:\n            counts[char] = counts.get(char, 0) + 1\n        \n        for char in t:\n            if char not in counts or counts[char] == 0:\n                return False\n            counts[char] -= 1\n            \n        return True\n\n# Alternative pythonic solution\n# from collections import Counter\n# return Counter(s) == Counter(t)\n```",
                    "javascript": "```javascript\n/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isAnagram = function(s, t) {\n    if (s.length !== t.length) {\n        return false;\n    }\n    const counts = {};\n    for (const char of s) {\n        counts[char] = (counts[char] || 0) + 1;\n    }\n    for (const char of t) {\n        if (!counts[char]) { // checks for undefined or 0\n            return false;\n        }\n        counts[char]--;\n    }\n    return true;\n};\n```"
                }
            },
            {
                "title": "Longest Substring Without Repeating Characters",
                "description": "Given a string `s`, find the length of the longest substring without repeating characters.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
                    "gfg": "https://www.geeksforgeeks.org/problems/length-of-the-longest-substring-1587115620/1"
                },
                "pattern": "Sliding Window with a hash map or set to track characters in the current window.",
                "solutions": {
                    "cpp": "```cpp\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(std::string s) {\n        std::unordered_map<char, int> charIndexMap;\n        int maxLength = 0;\n        int start = 0;\n\n        for (int end = 0; end < s.length(); ++end) {\n            char rightChar = s[end];\n            if (charIndexMap.count(rightChar) && charIndexMap[rightChar] >= start) {\n                start = charIndexMap[rightChar] + 1;\n            }\n            charIndexMap[rightChar] = end;\n            maxLength = std::max(maxLength, end - start + 1);\n        }\n        return maxLength;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_index_map = {}\n        max_length = 0\n        start = 0\n        \n        for end, char in enumerate(s):\n            if char in char_index_map and char_index_map[char] >= start:\n                start = char_index_map[char] + 1\n            char_index_map[char] = end\n            max_length = max(max_length, end - start + 1)\n            \n        return max_length\n```",
                    "javascript": "```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    const charIndexMap = new Map();\n    let maxLength = 0;\n    let start = 0;\n\n    for (let end = 0; end < s.length; end++) {\n        const rightChar = s[end];\n        if (charIndexMap.has(rightChar) && charIndexMap.get(rightChar) >= start) {\n            start = charIndexMap.get(rightChar) + 1;\n        }\n        charIndexMap.set(rightChar, end);\n        maxLength = Math.max(maxLength, end - start + 1);\n    }\n    return maxLength;\n};\n```"
                }
            },
            {
                "title": "String to Integer (atoi)",
                "description": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/string-to-integer-atoi/",
                    "gfg": "https://www.geeksforgeeks.org/problems/implement-atoi/1"
                },
                "pattern": "Careful string parsing, handling edge cases like whitespace, signs, and overflow.",
                "solutions": {
                    "cpp": "```cpp\n#include <string>\n#include <limits>\n\nclass Solution {\npublic:\n    int myAtoi(std::string s) {\n        int i = 0;\n        int sign = 1;\n        long long result = 0;\n\n        while (i < s.length() && s[i] == ' ') i++;\n\n        if (i < s.length() && (s[i] == '+' || s[i] == '-')) {\n            sign = (s[i++] == '-') ? -1 : 1;\n        }\n\n        while (i < s.length() && isdigit(s[i])) {\n            result = result * 10 + (s[i++] - '0');\n            if (result * sign > INT_MAX) return INT_MAX;\n            if (result * sign < INT_MIN) return INT_MIN;\n        }\n\n        return result * sign;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        s = s.strip()\n        if not s:\n            return 0\n\n        sign = 1\n        i = 0\n        if s[0] == '-':\n            sign = -1\n            i = 1\n        elif s[0] == '+':\n            i = 1\n\n        result = 0\n        while i < len(s) and s[i].isdigit():\n            result = result * 10 + int(s[i])\n            i += 1\n\n        result *= sign\n\n        # Handle overflow\n        int_max = 2**31 - 1\n        int_min = -2**31\n        if result > int_max:\n            return int_max\n        if result < int_min:\n            return int_min\n\n        return result\n```",
                    "javascript": "```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar myAtoi = function(s) {\n    let i = 0;\n    let sign = 1;\n    let result = 0;\n\n    s = s.trim();\n\n    if (i < s.length && (s[i] === '+' || s[i] === '-')) {\n        sign = (s[i] === '-') ? -1 : 1;\n        i++;\n    }\n\n    while (i < s.length && s[i] >= '0' && s[i] <= '9') {\n        result = result * 10 + (s[i] - '0');\n        i++;\n    }\n\n    result *= sign;\n\n    const INT_MAX = 2**31 - 1;\n    const INT_MIN = -(2**31);\n\n    if (result > INT_MAX) return INT_MAX;\n    if (result < INT_MIN) return INT_MIN;\n\n    return result;\n};\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** String problems are very common and test your attention to detail and knowledge of built-in functions. They are often combined with other patterns like sliding window or dynamic programming.\n\n### Tips:\n- **Clarify Character Set:** Ask if the string contains only ASCII characters or Unicode. This affects the size of any character-counting array you might use (26 for lowercase English, 128 for ASCII, etc.).\n- **Immutability Gotcha:** Remember that in languages like Python or JavaScript, repeatedly concatenating strings in a loop (e.g., `s += char`) is inefficient because it creates a new string each time. Use a list of characters and `''.join()` them at the end for better performance."
    },
    "Sorting": {
        "topicName": "Sorting",
        "theoryAndFeatures": "Sorting is the process of arranging items in a collection (like an array) in a specific order (ascending or descending). It's a fundamental algorithmic concept used to organize data, which in turn makes other operations like searching much more efficient.\n\n### Key Algorithms & Features:\n- **Bubble/Selection/Insertion Sort:** Simple, intuitive algorithms with O(n²) complexity. Good for small datasets or educational purposes, but inefficient for large inputs.\n- **Merge Sort:** A 'Divide and Conquer' algorithm. It divides the array in half, sorts each half recursively, and then merges them. It's **stable** (maintains the relative order of equal elements) and has a guaranteed O(n log n) time complexity, but requires O(n) extra space.\n- **Quick Sort:** Also a 'Divide and Conquer' algorithm. It picks a 'pivot' element and partitions the array around it. It's generally faster in practice than Merge Sort due to better cache performance and operates in-place (O(log n) space for recursion stack). However, its worst-case time complexity is O(n²).\n- **Heap Sort:** Uses a Heap data structure to sort elements. It's in-place (O(1) space) and has a guaranteed O(n log n) time complexity, but is generally not stable.\n\n### Complexity Analysis:\n| Algorithm         | Best Case     | Average Case  | Worst Case    | Space Complexity | Stable | \n| ----------------- | ------------- | ------------- | ------------- | ---------------- | ------ |\n| Bubble Sort       | O(n)          | O(n²)         | O(n²)         | O(1)             | Yes    |\n| Insertion Sort    | O(n)          | O(n²)         | O(n²)         | O(1)             | Yes    |\n| Selection Sort    | O(n²)         | O(n²)         | O(n²)         | O(1)             | No     |\n| Merge Sort        | O(n log n)    | O(n log n)    | O(n log n)    | O(n)             | Yes    |\n| Quick Sort        | O(n log n)    | O(n log n)    | O(n²)         | O(log n)         | No     |\n| Heap Sort         | O(n log n)    | O(n log n)    | O(n log n)    | O(1)             | No     |",
        "realWorldAnalogy": "Sorting is like arranging books on a **bookshelf** 📚. You can do it simply by picking one book at a time and putting it in the right spot (Insertion Sort). Or, you could split the books into two piles, sort each pile, and then merge them back onto the shelf (Merge Sort). The goal is the same: to make finding a specific book (searching) much easier later.",
        "advancedTopics": "- **Non-Comparison Sorts:** Algorithms like **Radix Sort** and **Counting Sort** can sort in linear time (O(n)) under specific assumptions (e.g., integer keys within a limited range).\n- **External Sorting:** Techniques used when the data to be sorted is too large to fit into memory, requiring the use of external storage like a hard disk.\n- **Stability in Sorting:** A property of sorting algorithms where two objects with equal keys appear in the same order in the sorted output as they appear in the input.",
        "codingProblems": [
            {
                "title": "Sort Colors (Dutch National Flag problem)",
                "description": "Given an array `nums` with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the order red, white, and blue.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/sort-colors/",
                    "gfg": "https://www.geeksforgeeks.org/problems/sort-an-array-of-0s-1s-and-2s4231/1"
                },
                "pattern": "Three Pointers (low, mid, high) to partition the array in a single pass.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <utility>\n\nclass Solution {\npublic:\n    void sortColors(std::vector<int>& nums) {\n        int low = 0, mid = 0, high = nums.size() - 1;\n        // We use 0 for red, 1 for white, 2 for blue\n        while (mid <= high) {\n            switch (nums[mid]) {\n                case 0: // Red\n                    std::swap(nums[low++], nums[mid++]);\n                    break;\n                case 1: // White\n                    mid++;\n                    break;\n                case 2: // Blue\n                    std::swap(nums[mid], nums[high--]);\n                    break;\n            }\n        }\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def sortColors(self, nums: list[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low, mid, high = 0, 0, len(nums) - 1\n        # 0: red, 1: white, 2: blue\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else: # nums[mid] == 2\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n```",
                    "javascript": "```javascript\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar sortColors = function(nums) {\n    let low = 0, mid = 0, high = nums.length - 1;\n    \n    while (mid <= high) {\n        if (nums[mid] === 0) {\n            [nums[low], nums[mid]] = [nums[mid], nums[low]];\n            low++;\n            mid++;\n        } else if (nums[mid] === 1) {\n            mid++;\n        } else { // nums[mid] === 2\n            [nums[mid], nums[high]] = [nums[high], nums[mid]];\n            high--;\n        }\n    }\n};\n```"
                }
            },
            {
                "title": "Merge Intervals",
                "description": "Given an array of `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals, and return an array of the non-overlapping intervals.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/merge-intervals/",
                    "gfg": "https://www.geeksforgeeks.org/problems/merging-intervals/1"
                },
                "pattern": "Sorting as a pre-processing step. Sort intervals by their start times.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<std::vector<int>> merge(std::vector<std::vector<int>>& intervals) {\n        if (intervals.empty()) {\n            return {};\n        }\n        \n        std::sort(intervals.begin(), intervals.end());\n        \n        std::vector<std::vector<int>> mergedIntervals;\n        mergedIntervals.push_back(intervals[0]);\n        \n        for (int i = 1; i < intervals.size(); ++i) {\n            if (intervals[i][0] <= mergedIntervals.back()[1]) {\n                mergedIntervals.back()[1] = std::max(mergedIntervals.back()[1], intervals[i][1]);\n            } else {\n                mergedIntervals.push_back(intervals[i]);\n            }\n        }\n        \n        return mergedIntervals;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def merge(self, intervals: list[list[int]]) -> list[list[int]]:\n        if not intervals:\n            return []\n        \n        intervals.sort(key=lambda x: x[0])\n        \n        merged = [intervals[0]]\n        \n        for i in range(1, len(intervals)):\n            last_merged = merged[-1]\n            current = intervals[i]\n            \n            if current[0] <= last_merged[1]:\n                last_merged[1] = max(last_merged[1], current[1])\n            else:\n                merged.append(current)\n                \n        return merged\n```",
                    "javascript": "```javascript\n/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nvar merge = function(intervals) {\n    if (intervals.length === 0) {\n        return [];\n    }\n    \n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    const merged = [intervals[0]];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        const lastMerged = merged[merged.length - 1];\n        const current = intervals[i];\n        \n        if (current[0] <= lastMerged[1]) {\n            lastMerged[1] = Math.max(lastMerged[1], current[1]);\n        } else {\n            merged.push(current);\n        }\n    }\n    \n    return merged;\n};\n```"
                }
            },
            {
                "title": "Kth Largest Element in an Array",
                "description": "Given an integer array `nums` and an integer `k`, return the `k`th largest element in the array.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
                    "gfg": "https://www.geeksforgeeks.org/problems/kth-smallest-element5635/1"
                },
                "pattern": "Quickselect (a variation of Quicksort) or Min-Heap.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <queue>\n#include <functional>\n\nclass Solution {\npublic:\n    // Min-Heap approach O(N log K)\n    int findKthLargest(std::vector<int>& nums, int k) {\n        std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n        for (int num : nums) {\n            minHeap.push(num);\n            if (minHeap.size() > k) {\n                minHeap.pop();\n            }\n        }\n        return minHeap.top();\n    }\n};\n```",
                    "python": "```python\nimport heapq\n\nclass Solution:\n    # Min-Heap approach O(N log K)\n    def findKthLargest(self, nums: list[int], k: int) -> int:\n        min_heap = []\n        for num in nums:\n            heapq.heappush(min_heap, num)\n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n        return min_heap[0]\n\n# Alternative pythonic solution O(N)\n# def findKthLargest(self, nums, k):\n#   return heapq.nlargest(k, nums)[-1]\n```",
                    "javascript": "```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\n// A simple solution is to sort, which is O(N log N)\nvar findKthLargest = function(nums, k) {\n    nums.sort((a, b) => b - a); // Sort in descending order\n    return nums[k - 1];\n};\n\n// A more optimal solution requires implementing Quickselect or using a Min-Heap library.\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** You will almost never be asked to implement a sorting algorithm from scratch (unless it's a very junior role). However, you **must know** their complexities and properties. Many hard problems are made easy by first sorting the input data. \n\n### Tips:\n- **Know Your Language's Sort:** Understand the complexity of your language's default sort function. For example, Python's `sort()` (Timsort) and C++'s `std::sort` (Introsort) are highly optimized and have an average complexity of O(n log n).\n- **Look for 'Sorted' Clues:** If a problem involves intervals, finding duplicates, or any kind of ordering, your first thought should often be, 'What if I sort this first?'."
    },
    "Searching": {
        "topicName": "Searching",
        "theoryAndFeatures": "Searching algorithms are designed to retrieve information stored within a data structure. The choice of algorithm depends heavily on the structure and state of the data, particularly whether it's sorted.\n\n### Key Algorithms & Features:\n- **Linear Search:** The simplest method. It sequentially checks each element of a list until a match is found or the whole list has been searched. It works on unsorted data.\n  - **Complexity:** O(n) time, O(1) space.\n- **Binary Search:** A highly efficient 'Divide and Conquer' algorithm that requires the data to be **sorted**. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. This is repeated until the value is found or the interval is empty.\n  - **Complexity:** O(log n) time, O(1) space (iterative), O(log n) space (recursive).\n\n### Complexity Analysis:\n| Algorithm      | Data Structure | Average Case | Worst Case   | Space Complexity |\n| -------------- | -------------- | ------------ | ------------ | ---------------- |\n| Linear Search  | Any            | O(n)         | O(n)         | O(1)             |\n| Binary Search  | Sorted Array   | O(log n)     | O(log n)     | O(1)             |",
        "realWorldAnalogy": "Searching is like looking for a word in a **dictionary** 📖.\n- **Linear Search:** You start at the first page and read every word one by one until you find the one you're looking for. This is slow and inefficient.\n- **Binary Search:** You open the dictionary to the middle. If your word comes alphabetically before the words on that page, you know it's in the first half. If it comes after, you know it's in the second half. You repeat this process, cutting the problem in half each time, until you find the word very quickly.",
        "advancedTopics": "- **Ternary Search:** A divide and conquer algorithm that divides the search space into three parts instead of two. It's applicable for strictly unimodal functions.\n- **Jump Search:** An improvement over linear search for large arrays. It checks fewer elements by jumping ahead by fixed steps.\n- **Interpolation Search:** An improvement over Binary Search for uniformly distributed data. It positions probes based on the value of the key being searched.\n- **Binary Search on Answer:** A powerful technique where you use binary search not on the array itself, but on the range of possible answers to a problem.",
        "codingProblems": [
            {
                "title": "Binary Search",
                "description": "Given a sorted array of integers `nums` and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return -1.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/binary-search/",
                    "gfg": "https://www.geeksforgeeks.org/problems/binary-search-1587115620/1"
                },
                "pattern": "Standard iterative binary search implementation.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n\nclass Solution {\npublic:\n    int search(std::vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2; // Avoids potential overflow\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return -1;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def search(self, nums: list[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n```",
                    "javascript": "```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n};\n```"
                }
            },
            {
                "title": "Search in Rotated Sorted Array",
                "description": "An array sorted in ascending order is rotated. Given a target value, return its index if it exists in the array, otherwise return -1. You must write an algorithm with O(log n) runtime complexity.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
                    "gfg": "https://www.geeksforgeeks.org/problems/search-in-a-rotated-array0959/1"
                },
                "pattern": "Modified Binary Search. Determine which half of the array is sorted and adjust pointers accordingly.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n\nclass Solution {\npublic:\n    int search(std::vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) return mid;\n\n            // Check if left half is sorted\n            if (nums[left] <= nums[mid]) {\n                if (target >= nums[left] && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } \n            // Else, right half must be sorted\n            else {\n                if (target > nums[mid] && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def search(self, nums: list[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            \n            # Left half is sorted\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # Right half is sorted\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n```",
                    "javascript": "```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    let left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] === target) return mid;\n\n        // Check if left half is sorted\n        if (nums[left] <= nums[mid]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } \n        // Else, right half must be sorted\n        else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n};\n```"
                }
            },
            {
                "title": "Find Minimum in Rotated Sorted Array",
                "description": "An array sorted in ascending order is rotated. Find the minimum element. You must write an algorithm that runs in O(log n) time.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
                    "gfg": "https://www.geeksforgeeks.org/problems/minimum-element-in-a-sorted-and-rotated-array3611/1"
                },
                "pattern": "Modified Binary Search. The minimum element is the 'inflection point'.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n\nclass Solution {\npublic:\n    int findMin(std::vector<int>& nums) {\n        int left = 0, right = nums.size() - 1;\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            // If mid is greater than the rightmost element, the inflection point is to the right\n            if (nums[mid] > nums[right]) {\n                left = mid + 1;\n            } \n            // Otherwise, the inflection point is at mid or to its left\n            else {\n                right = mid;\n            }\n        }\n        // The loop terminates when left == right, which is the minimum element\n        return nums[left];\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def findMin(self, nums: list[int]) -> int:\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            # The minimum element is in the right half\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            # The minimum element is in the left half (including mid)\n            else:\n                right = mid\n        \n        return nums[left]\n```",
                    "javascript": "```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function(nums) {\n    let left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n};\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Binary Search is a **critical** topic. Interviewers love it because it's simple to understand but tricky to implement correctly. It's often the key to optimizing a brute-force solution from O(n) to O(log n).\n\n### Tips:\n- **Off-by-One Errors:** The biggest challenge in binary search is avoiding off-by-one errors. Be very careful with your loop conditions (`left <= right` vs. `left < right`) and pointer updates (`right = mid` vs. `right = mid - 1`).\n- **Not Just for Arrays:** Binary search is a pattern, not just an algorithm for arrays. You can use it on any problem where you can define a monotonic 'search space'. For example, finding the minimum speed to finish a task in a given time. If you can complete it at speed `X`, you can also complete it at any speed `> X`."
    },
    "Hashing": {
        "topicName": "Hashing",
        "theoryAndFeatures": "Hashing is a technique used to map data of arbitrary size to data of a fixed size. This is done using a **hash function**. The output of a hash function is called a **hash value** or **hash**. These values are stored in a data structure called a **hash table** (or hash map, dictionary, associative array).\n\n### Key Concepts:\n- **Hash Function:** A function that takes an input (or 'key') and returns an integer (the 'hash'), which is used as an index in an array to locate the value.\n- **Hash Table:** A data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.\n- **Collision:** When two different keys map to the same index. This is a common problem that must be handled.\n- **Collision Resolution:**\n    - **Chaining (or Separate Chaining):** Each bucket in the hash table stores a pointer to a linked list of all the key-value pairs that hashed to that index.\n    - **Open Addressing:** All key-value pairs are stored in the hash table itself. When a collision occurs, the algorithm probes for the next empty slot (e.g., linear probing, quadratic probing).\n\n### Complexity Analysis:\n| Operation         | Average Case | Worst Case   | Explanation                                                              |\n| ----------------- | ------------ | ------------ | ------------------------------------------------------------------------ |\n| Insert            | O(1)         | O(n)         | Average case is constant. Worst case occurs if all keys collide.         |\n| Delete            | O(1)         | O(n)         | Same as insertion.                                                       |\n| Search            | O(1)         | O(n)         | Same as insertion.                                                       |",
        "realWorldAnalogy": "A hash table is like a **library's card catalog** 📇. The book's title (the key) is processed by a system (the hash function, like the Dewey Decimal System) that tells you exactly which drawer (the index or bucket) to look in. Instead of searching the whole library, you go directly to the right spot. If multiple books end up in the same drawer (a collision), you just have a short list to look through inside that drawer (chaining).",
        "advancedTopics": "- **Consistent Hashing:** A special kind of hashing used in distributed systems to minimize data reshuffling when nodes are added or removed.\n- **Cryptographic Hash Functions:** Functions like SHA-256 that are designed to be one-way and collision-resistant, used for data integrity and security, not for hash tables.\n- **Cuckoo Hashing & Robin Hood Hashing:** Advanced open addressing strategies for collision resolution that offer better performance characteristics under high load factors.",
        "codingProblems": [
            {
                "title": "Group Anagrams",
                "description": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/group-anagrams/",
                    "gfg": "https://www.geeksforgeeks.org/problems/print-anagrams-together/1"
                },
                "pattern": "Use a hash map where the key is a canonical representation of an anagram (e.g., sorted string or character count).",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {\n        std::unordered_map<std::string, std::vector<std::string>> anagramMap;\n        for (const std::string& s : strs) {\n            std::string key = s;\n            std::sort(key.begin(), key.end());\n            anagramMap[key].push_back(s);\n        }\n\n        std::vector<std::vector<std::string>> result;\n        for (auto const& [key, val] : anagramMap) {\n            result.push_back(val);\n        }\n        return result;\n    }\n};\n```",
                    "python": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\n        anagram_map = defaultdict(list)\n        for s in strs:\n            # A tuple of character counts can also be used as a key\n            # e.g., key = [0]*26; for c in s: key[ord(c) - ord('a')] += 1\n            # key = tuple(key)\n            key = \"\".join(sorted(s))\n            anagram_map[key].append(s)\n        return list(anagram_map.values())\n```",
                    "javascript": "```javascript\n/**\n * @param {string[]} strs\n * @return {string[][]}\n */\nvar groupAnagrams = function(strs) {\n    const anagramMap = new Map();\n    for (const s of strs) {\n        const key = s.split('').sort().join('');\n        if (!anagramMap.has(key)) {\n            anagramMap.set(key, []);\n        }\n        anagramMap.get(key).push(s);\n    }\n    return Array.from(anagramMap.values());\n};\n```"
                }
            },
            {
                "title": "Two Sum",
                "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/two-sum/",
                    "gfg": "https://www.geeksforgeeks.org/problems/two-sum-1587115621/1"
                },
                "pattern": "This is the canonical hash map problem. Store numbers you've seen and their indices in a map, and for each new number, check if its complement exists in the map.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    std::vector<int> twoSum(std::vector<int>& nums, int target) {\n        std::unordered_map<int, int> numMap;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (numMap.count(complement)) {\n                return {numMap[complement], i};\n            }\n            numMap[nums[i]] = i;\n        }\n        return {};\n    }\n}; \n```",
                    "python": "```python\nclass Solution:\n    def twoSum(self, nums: list[int], target: int) -> list[int]:\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n        return []\n```",
                    "javascript": "```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const numMap = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (numMap.has(complement)) {\n            return [numMap.get(complement), i];\n        }\n        numMap.set(nums[i], i);\n    }\n    return [];\n};\n```"
                }
            },
            {
                "title": "First Unique Character in a String",
                "description": "Given a string `s`, find the first non-repeating character in it and return its index. If it does not exist, return -1.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/first-unique-character-in-a-string/",
                    "gfg": "https://www.geeksforgeeks.org/problems/non-repeating-character-1587115620/1"
                },
                "pattern": "Use a hash map to store the counts of each character. Iterate through the string a second time to find the first character with a count of 1.",
                "solutions": {
                    "cpp": "```cpp\n#include <string>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    int firstUniqChar(std::string s) {\n        std::unordered_map<char, int> counts;\n        for (char c : s) {\n            counts[c]++;\n        }\n        for (int i = 0; i < s.length(); ++i) {\n            if (counts[s[i]] == 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n```",
                    "python": "```python\nimport collections\n\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        # The Counter object is a specialized dictionary subclass for counting hashable objects\n        counts = collections.Counter(s)\n        \n        for i, char in enumerate(s):\n            if counts[char] == 1:\n                return i\n        return -1\n```",
                    "javascript": "```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar firstUniqChar = function(s) {\n    const counts = new Map();\n    for (const char of s) {\n        counts.set(char, (counts.get(char) || 0) + 1);\n    }\n    \n    for (let i = 0; i < s.length; i++) {\n        if (counts.get(s[i]) === 1) {\n            return i;\n        }\n    }\n    \n    return -1;\n};\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Hash maps are one of the most versatile and important tools in a programmer's toolkit. They are the key to solving a huge number of interview problems efficiently. If you're stuck on a problem, always ask yourself: 'Can a hash map help here?'.\n\n### Tips:\n- **Time-Space Tradeoff:** Using a hash map is the classic example of a time-space tradeoff. You use O(n) extra space to reduce search/lookup times from O(n) or O(log n) down to O(1) on average.\n- **Choosing a Key:** The power of a hash map comes from choosing a good key. For anagrams, the key is the sorted string. For problems involving pairs, the key is often the number itself. Learning to identify the right key is crucial."
    },
    "LinkedList": {
        "topicName": "Linked List",
        "theoryAndFeatures": "A **Linked List** is a linear data structure where elements are not stored at contiguous memory locations. Instead, elements are stored in **nodes**, where each node contains two parts: the **data** and a **pointer** (or reference) to the next node in the sequence. The first node is called the **head**, and the last node's pointer points to `null`.\n\n### Key Features:\n- **Dynamic Size:** Can grow and shrink easily at runtime.\n- **Non-Contiguous Memory:** Nodes can be scattered anywhere in memory.\n- **Efficient Insertions/Deletions:** Adding or removing nodes is very efficient (O(1)) if you have a pointer to the relevant location, as it only requires changing a few pointers. This is a major advantage over arrays.\n- **No Random Access:** To access the Nth element, you must traverse the list from the head, which takes O(n) time.\n\n### Variants:\n- **Singly Linked List:** Each node points only to the next node.\n- **Doubly Linked List:** Each node points to both the next and the previous node, allowing for bidirectional traversal.\n- **Circular Linked List:** The last node's pointer points back to the head instead of `null`.\n\n### Complexity Analysis:\n| Operation                 | Average Case | Worst Case   | Explanation                                                              |\n| ------------------------- | ------------ | ------------ | ------------------------------------------------------------------------ |\n| Access (by index)         | O(n)         | O(n)         | Must traverse from the head.                                             |\n| Search (by value)         | O(n)         | O(n)         | Must traverse from the head.                                             |\n| Insertion (at head)       | O(1)         | O(1)         | Just need to update the head pointer.                                    |\n| Insertion (at tail)       | O(n)* | O(n)* | *O(1) if a pointer to the tail node is maintained. Otherwise, O(n).       |\n| Deletion (at head)        | O(1)         | O(1)         | Just need to update the head pointer.                                    |\n| Deletion (middle)         | O(n)         | O(n)         | O(1) to perform the operation, but O(n) to find the node first.          |",
        "realWorldAnalogy": "A linked list is like a **treasure hunt** 🏴‍☠️. You start with the first clue (the `head`). This clue tells you the location of the next clue. You follow the chain of clues one by one until you reach the final one, which points to nowhere (`null`), indicating the end of the hunt. You can't just jump to the 5th clue; you have to follow the first four to get there.",
        "advancedTopics": "- **Skip List:** A probabilistic data structure built on top of linked lists that allows for O(log n) search time on average.\n- **Unrolled Linked List:** A variation that stores multiple elements in each node to improve cache performance.\n- **XOR Linked List:** A memory-efficient version of a doubly linked list that uses bitwise XOR to store both next and previous pointers in a single field.",
        "codingProblems": [
            {
                "title": "Reverse Linked List",
                "description": "Given the `head` of a singly linked list, reverse the list, and return the new `head`.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/reverse-linked-list/",
                    "gfg": "https://www.geeksforgeeks.org/problems/reverse-a-linked-list/1"
                },
                "pattern": "Iterative approach with three pointers: previous, current, and next.",
                "solutions": {
                    "cpp": "```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n * int val;\n * ListNode *next;\n * ListNode() : val(0), next(nullptr) {}\n * ListNode(int x) : val(x), next(nullptr) {}\n * ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* current = head;\n        while (current != nullptr) {\n            ListNode* nextTemp = current->next;\n            current->next = prev;\n            prev = current;\n            current = nextTemp;\n        }\n        return prev;\n    }\n};\n```",
                    "python": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev, current = None, head\n        while current:\n            next_temp = current.next\n            current.next = prev\n            prev = current\n            current = next_temp\n        return prev\n```",
                    "javascript": "```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n * this.val = (val===undefined ? 0 : val)\n * this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function(head) {\n    let prev = null;\n    let current = head;\n    while (current) {\n        const nextTemp = current.next;\n        current.next = prev;\n        prev = current;\n        current = nextTemp;\n    }\n    return prev;\n};\n```"
                }
            },
            {
                "title": "Linked List Cycle",
                "description": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/linked-list-cycle/",
                    "gfg": "https://www.geeksforgeeks.org/problems/detect-loop-in-linked-list/1"
                },
                "pattern": "Two Pointers (Floyd's Tortoise and Hare algorithm). Use a slow pointer and a fast pointer.",
                "solutions": {
                    "cpp": "```cpp\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if (!head || !head->next) {\n            return false;\n        }\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        if not head or not head.next:\n            return False\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n```",
                    "javascript": "```javascript\nvar hasCycle = function(head) {\n    if (!head || !head.next) {\n        return false;\n    }\n    let slow = head;\n    let fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            return true;\n        }\n    }\n    return false;\n};\n```"
                }
            },
            {
                "title": "Merge Two Sorted Lists",
                "description": "Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/merge-two-sorted-lists/",
                    "gfg": "https://www.geeksforgeeks.org/problems/merge-two-sorted-linked-lists/1"
                },
                "pattern": "Iterative merging using a dummy head node.",
                "solutions": {
                    "cpp": "```cpp\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy(0);\n        ListNode* tail = &dummy;\n        \n        while (list1 != nullptr && list2 != nullptr) {\n            if (list1->val < list2->val) {\n                tail->next = list1;\n                list1 = list1->next;\n            } else {\n                tail->next = list2;\n                list2 = list2->next;\n            }\n            tail = tail->next;\n        }\n        \n        if (list1 != nullptr) {\n            tail->next = list1;\n        } else {\n            tail->next = list2;\n        }\n        \n        return dummy.next;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        tail = dummy\n\n        while list1 and list2:\n            if list1.val < list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            tail = tail.next\n\n        if list1:\n            tail.next = list1\n        elif list2:\n            tail.next = list2\n\n        return dummy.next\n```",
                    "javascript": "```javascript\nvar mergeTwoLists = function(list1, list2) {\n    const dummy = new ListNode();\n    let tail = dummy;\n\n    while (list1 && list2) {\n        if (list1.val < list2.val) {\n            tail.next = list1;\n            list1 = list1.next;\n        } else {\n            tail.next = list2;\n            list2 = list2.next;\n        }\n        tail = tail.next;\n    }\n\n    if (list1) {\n        tail.next = list1;\n    } else if (list2) {\n        tail.next = list2;\n    }\n\n    return dummy.next;\n};\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Linked list questions are very common, especially for entry-level roles. They test your ability to handle pointers and references, manage state carefully, and think about edge cases (e.g., empty list, single-node list, operations on head/tail).\n\n### Tips:\n- **Draw It Out:** Always use a whiteboard or a piece of paper to draw the nodes and trace how the pointers change. It's extremely easy to get confused otherwise.\n- **The Dummy Head Node:** For problems that involve building a new list (like merging or partitioning), using a `dummy` head node is a powerful trick. It simplifies the code by removing the need to handle the special case of inserting into an empty list.\n- **Master Two Pointers:** The fast/slow pointer technique is essential for cycle detection and finding the middle of a list. "
    },
    "Stack": {
        "topicName": "Stack",
        "theoryAndFeatures": "A **Stack** is a linear data structure that follows the **LIFO (Last-In, First-Out)** principle. The last element added to the stack will be the first one to be removed. It can be implemented using an array, dynamic array, or a linked list.\n\n### Key Features:\n- **LIFO Principle:** The core behavior of a stack.\n- **Restricted Access:** All additions (`push`) and removals (`pop`) happen at one end, called the **top**.\n- **Core Operations:**\n    - **push(element):** Adds an element to the top. (O(1))\n    - **pop():** Removes and returns the top element. (O(1))\n    - **peek() or top():** Returns the top element without removing it. (O(1))\n    - **isEmpty():** Checks if the stack is empty. (O(1))\n\n### Complexity Analysis:\n| Operation         | Average Case | Worst Case   | Implementation Notes                             |\n| ----------------- | ------------ | ------------ | ------------------------------------------------ |\n| Push              | O(1)         | O(1)* | *Amortized O(1) for dynamic array implementation. |\n| Pop               | O(1)         | O(1)         |                                                  |\n| Peek / Top        | O(1)         | O(1)         |                                                  |\n| Search            | O(n)         | O(n)         | Requires iterating through the elements.         |",
        "realWorldAnalogy": "A stack is like a **stack of plates** 🍽️. You can only add a new plate to the top, and you can only take a plate from the top. The plate you put on last is the first one you take off. Another great analogy is the **Undo** feature (Ctrl+Z) in a text editor; each action is pushed onto a stack, and 'undo' pops the most recent action off.",
        "advancedTopics": "- **Call Stack:** In programming, the call stack keeps track of active function calls. When a function is called, a 'stack frame' is pushed, and when it returns, it's popped.\n- **Monotonic Stack:** A powerful pattern where the stack maintains elements in a strictly increasing or decreasing order. It's used to efficiently solve problems involving finding the 'next greater/smaller element'.",
        "codingProblems": [
            {
                "title": "Valid Parentheses",
                "description": "Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/valid-parentheses/",
                    "gfg": "https://www.geeksforgeeks.org/problems/parenthesis-checker2744/1"
                },
                "pattern": "The canonical stack problem. Push opening brackets, pop when a matching closing bracket is found.",
                "solutions": {
                    "cpp": "```cpp\n#include <stack>\n#include <string>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    bool isValid(std::string s) {\n        std::stack<char> st;\n        std::unordered_map<char, char> mapping = {{')', '('}, {']', '['}, {'}', '{'}};\n        for (char c : s) {\n            if (mapping.count(c)) { // It's a closing bracket\n                if (st.empty() || st.top() != mapping[c]) {\n                    return false;\n                }\n                st.pop();\n            } else { // It's an opening bracket\n                st.push(c);\n            }\n        }\n        return st.empty();\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        mapping = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n        for char in s:\n            if char in mapping: # It's a closing bracket\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else: # It's an opening bracket\n                stack.append(char)\n        return not stack\n```",
                    "javascript": "```javascript\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    const stack = [];\n    const mapping = {\n        ')': '(',\n        ']': '[',\n        '}': '{'\n    };\n    for (const char of s) {\n        if (mapping[char]) { // It's a closing bracket\n            const topElement = stack.length ? stack.pop() : '#';\n            if (mapping[char] !== topElement) {\n                return false;\n            }\n        } else { // It's an opening bracket\n            stack.push(char);\n        }\n    }\n    return stack.length === 0;\n};\n```"
                }
            },
            {
                "title": "Min Stack",
                "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/min-stack/",
                    "gfg": "https://www.geeksforgeeks.org/problems/get-minimum-element-from-stack/1"
                },
                "pattern": "Use two stacks, or a single stack that stores pairs of (value, current_minimum).",
                "solutions": {
                    "cpp": "```cpp\n#include <stack>\n#include <algorithm>\n\nclass MinStack {\nprivate:\n    std::stack<int> s1; // Main stack\n    std::stack<int> s2; // Min-tracking stack\n\npublic:\n    MinStack() {}\n    \n    void push(int val) {\n        s1.push(val);\n        if (s2.empty() || val <= s2.top()) {\n            s2.push(val);\n        }\n    }\n    \n    void pop() {\n        if (s1.top() == s2.top()) {\n            s2.pop();\n        }\n        s1.pop();\n    }\n    \n    int top() {\n        return s1.top();\n    }\n    \n    int getMin() {\n        return s2.top();\n    }\n};\n```",
                    "python": "```python\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        if self.stack[-1] == self.min_stack[-1]:\n            self.min_stack.pop()\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.min_stack[-1]\n```",
                    "javascript": "```javascript\nclass MinStack {\n    constructor() {\n        this.stack = [];\n        this.minStack = [];\n    }\n\n    push(val) {\n        this.stack.push(val);\n        if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {\n            this.minStack.push(val);\n        }\n    }\n\n    pop() {\n        const val = this.stack.pop();\n        if (val === this.minStack[this.minStack.length - 1]) {\n            this.minStack.pop();\n        }\n    }\n\n    top() {\n        return this.stack[this.stack.length - 1];\n    }\n\n    getMin() {\n        return this.minStack[this.minStack.length - 1];\n    }\n}\n```"
                }
            },
            {
                "title": "Daily Temperatures",
                "description": "Given a list of daily temperatures, produce a list that, for each day, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/daily-temperatures/",
                    "gfg": "https://www.geeksforgeeks.org/problems/daily-temperatures/1"
                },
                "pattern": "Monotonic Stack (decreasing). Store indices of temperatures on the stack.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <stack>\n\nclass Solution {\npublic:\n    std::vector<int> dailyTemperatures(std::vector<int>& temperatures) {\n        int n = temperatures.size();\n        std::vector<int> answer(n, 0);\n        std::stack<int> st; // Stores indices\n        \n        for (int i = 0; i < n; ++i) {\n            while (!st.empty() && temperatures[i] > temperatures[st.top()]) {\n                int prev_index = st.top();\n                st.pop();\n                answer[prev_index] = i - prev_index;\n            }\n            st.push(i);\n        }\n        return answer;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def dailyTemperatures(self, temperatures: list[int]) -> list[int]:\n        n = len(temperatures)\n        answer = [0] * n\n        stack = []  # Stores indices\n\n        for i, temp in enumerate(temperatures):\n            while stack and temp > temperatures[stack[-1]]:\n                prev_index = stack.pop()\n                answer[prev_index] = i - prev_index\n            stack.append(i)\n        \n        return answer\n```",
                    "javascript": "```javascript\n/**\n * @param {number[]} temperatures\n * @return {number[]}\n */\nvar dailyTemperatures = function(temperatures) {\n    const n = temperatures.length;\n    const answer = new Array(n).fill(0);\n    const stack = []; // Stores indices\n\n    for (let i = 0; i < n; i++) {\n        while (stack.length > 0 && temperatures[i] > temperatures[stack[stack.length - 1]]) {\n            const prevIndex = stack.pop();\n            answer[prevIndex] = i - prevIndex;\n        }\n        stack.push(i);\n    }\n    return answer;\n};\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Stacks are very frequently used in interviews, both as the primary data structure and as a tool within a more complex algorithm. Recognizing a LIFO pattern is key. If a problem involves nested structures, reversals, or finding the 'next greater' element, a stack should immediately come to mind.\n\n### Tips:\n- **Stack vs. Recursion:** Recursion implicitly uses the call stack. Many problems that can be solved recursively can also be solved iteratively with an explicit stack. Sometimes the iterative approach is required to avoid stack overflow on deep recursion.\n- **Store Indices, Not Values:** In many problems (like Daily Temperatures), it's more powerful to store the *indices* of elements on the stack rather than the values themselves. This allows you to calculate distances or retrieve original values when needed."
    },
    "Queue": {
        "topicName": "Queue",
        "theoryAndFeatures": "A **Queue** is a linear data structure that follows the **FIFO (First-In, First-Out)** principle. The first element added to the queue will be the first one to be removed. It's often implemented using a linked list or a circular array for efficiency.\n\n### Key Features:\n- **FIFO Principle:** The defining characteristic of a queue.\n- **Two Ends:** Has a **front** (or head) for removal and a **rear** (or tail) for insertion.\n- **Core Operations:**\n    - **enqueue(element):** Adds an element to the rear of the queue. (O(1))\n    - **dequeue():** Removes and returns the element from the front. (O(1))\n    - **front() or peek():** Returns the front element without removing it. (O(1))\n    - **isEmpty():** Checks if the queue is empty. (O(1))\n\n### Complexity Analysis:\n| Operation         | Average Case | Worst Case   | Implementation Notes                             |\n| ----------------- | ------------ | ------------ | ------------------------------------------------ |\n| Enqueue           | O(1)         | O(1)         |                                                  |\n| Dequeue           | O(1)         | O(1)         | *Using an array/list requires O(n) for shifting. A circular array or linked list is O(1). |\n| Front / Peek      | O(1)         | O(1)         |                                                  |\n| Search            | O(n)         | O(n)         | Requires iterating through the elements.         |",
        "realWorldAnalogy": "A queue is exactly like a **checkout line at a grocery store** 🛒. The first person to get in line is the first person to be served and leave. New people always join at the back of the line. Another example is a printer queue, where print jobs are processed in the order they were received.",
        "advancedTopics": "- **Deque (Double-Ended Queue):** A generalized queue that allows for efficient insertion and deletion at both the front and the back.\n- **Priority Queue:** An abstract data type where each element has a 'priority'. Elements with higher priority are served before elements with lower priority. Often implemented using a Heap.\n- **Breadth-First Search (BFS):** A fundamental graph and tree traversal algorithm that uses a queue to explore nodes level by level.",
        "codingProblems": [
            {
                "title": "Implement Queue using Stacks",
                "description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).",
                "links": {
                    "leetCode": "https://leetcode.com/problems/implement-queue-using-stacks/",
                    "gfg": "https://www.geeksforgeeks.org/problems/queue-using-stack/1"
                },
                "pattern": "Amortized analysis. Use one stack for pushing (in-stack) and another for popping (out-stack). Transfer elements only when the out-stack is empty.",
                "solutions": {
                    "cpp": "```cpp\n#include <stack>\n\nclass MyQueue {\nprivate:\n    std::stack<int> in_stack, out_stack;\n\n    void transfer() {\n        if (out_stack.empty()) {\n            while (!in_stack.empty()) {\n                out_stack.push(in_stack.top());\n                in_stack.pop();\n            }\n        }\n    }\npublic:\n    MyQueue() {}\n    \n    void push(int x) {\n        in_stack.push(x);\n    }\n    \n    int pop() {\n        transfer();\n        int top_val = out_stack.top();\n        out_stack.pop();\n        return top_val;\n    }\n    \n    int peek() {\n        transfer();\n        return out_stack.top();\n    }\n    \n    bool empty() {\n        return in_stack.empty() && out_stack.empty();\n    }\n};\n```",
                    "python": "```python\nclass MyQueue:\n\n    def __init__(self):\n        self.in_stack = []\n        self.out_stack = []\n\n    def push(self, x: int) -> None:\n        self.in_stack.append(x)\n\n    def _transfer(self) -> None:\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n\n    def pop(self) -> int:\n        self._transfer()\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        self._transfer()\n        return self.out_stack[-1]\n\n    def empty(self) -> bool:\n        return not self.in_stack and not self.out_stack\n```",
                    "javascript": "```javascript\nclass MyQueue {\n    constructor() {\n        this.inStack = [];\n        this.outStack = [];\n    }\n\n    _transfer() {\n        if (this.outStack.length === 0) {\n            while (this.inStack.length > 0) {\n                this.outStack.push(this.inStack.pop());\n            }\n        }\n    }\n\n    push(x) {\n        this.inStack.push(x);\n    }\n\n    pop() {\n        this._transfer();\n        return this.outStack.pop();\n    }\n\n    peek() {\n        this._transfer();\n        return this.outStack[this.outStack.length - 1];\n    }\n\n    empty() {\n        return this.inStack.length === 0 && this.outStack.length === 0;\n    }\n}\n```"
                }
            },
            {
                "title": "Number of Islands",
                "description": "Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/number-of-islands/",
                    "gfg": "https://www.geeksforgeeks.org/problems/find-the-number-of-islands/1"
                },
                "pattern": "Breadth-First Search (BFS) using a queue to explore adjacent land cells.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <queue>\n\nclass Solution {\npublic:\n    int numIslands(std::vector<std::vector<char>>& grid) {\n        if (grid.empty()) return 0;\n        int rows = grid.size();\n        int cols = grid[0].size();\n        int islands = 0;\n\n        for (int r = 0; r < rows; ++r) {\n            for (int c = 0; c < cols; ++c) {\n                if (grid[r][c] == '1') {\n                    islands++;\n                    bfs(grid, r, c);\n                }\n            }\n        }\n        return islands;\n    }\n\n    void bfs(std::vector<std::vector<char>>& grid, int r, int c) {\n        std::queue<std::pair<int, int>> q;\n        q.push({r, c});\n        grid[r][c] = '0'; // Mark as visited\n        int rows = grid.size();\n        int cols = grid[0].size();\n\n        while (!q.empty()) {\n            auto [row, col] = q.front();\n            q.pop();\n            int dr[] = {-1, 1, 0, 0};\n            int dc[] = {0, 0, -1, 1};\n            for (int i = 0; i < 4; ++i) {\n                int new_r = row + dr[i];\n                int new_c = col + dc[i];\n                if (new_r >= 0 && new_r < rows && new_c >= 0 && new_c < cols && grid[new_r][new_c] == '1') {\n                    q.push({new_r, new_c});\n                    grid[new_r][new_c] = '0';\n                }\n            }\n        }\n    }\n};\n```",
                    "python": "```python\nfrom collections import deque\n\nclass Solution:\n    def numIslands(self, grid: list[list[str]]) -> int:\n        if not grid:\n            return 0\n        rows, cols = len(grid), len(grid[0])\n        islands = 0\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == '1':\n                    islands += 1\n                    self.bfs(grid, r, c)\n        return islands\n\n    def bfs(self, grid, r, c):\n        q = deque([(r, c)])\n        grid[r][c] = '0' # Mark as visited\n        rows, cols = len(grid), len(grid[0])\n        \n        while q:\n            row, col = q.popleft()\n            directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n            for dr, dc in directions:\n                new_r, new_c = row + dr, col + dc\n                if 0 <= new_r < rows and 0 <= new_c < cols and grid[new_r][new_c] == '1':\n                    q.append((new_r, new_c))\n                    grid[new_r][new_c] = '0'\n```",
                    "javascript": "```javascript\n/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numIslands = function(grid) {\n    if (!grid || grid.length === 0) return 0;\n    const rows = grid.length;\n    const cols = grid[0].length;\n    let islands = 0;\n\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            if (grid[r][c] === '1') {\n                islands++;\n                bfs(grid, r, c);\n            }\n        }\n    }\n    return islands;\n};\n\nfunction bfs(grid, r, c) {\n    const q = [[r, c]];\n    grid[r][c] = '0'; // Mark visited\n    const rows = grid.length;\n    const cols = grid[0].length;\n\n    while (q.length > 0) {\n        const [row, col] = q.shift();\n        const directions = [[1,0], [-1,0], [0,1], [0,-1]];\n\n        for (const [dr, dc] of directions) {\n            const newR = row + dr;\n            const newC = col + dc;\n            if (newR >= 0 && newR < rows && newC >= 0 && newC < cols && grid[newR][newC] === '1') {\n                q.push([newR, newC]);\n                grid[newR][newC] = '0';\n            }\n        }\n    }\n}\n```"
                }
            },
            {
                "title": "Sliding Window Maximum",
                "description": "You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position, return the max sliding window.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/sliding-window-maximum/",
                    "gfg": "https://www.geeksforgeeks.org/problems/maximum-of-all-subarrays-of-size-k3101/1"
                },
                "pattern": "Monotonic Deque (double-ended queue). Keep a deque of indices, with the values at those indices in decreasing order.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <deque>\n\nclass Solution {\npublic:\n    std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\n        std::deque<int> dq; // Stores indices\n        std::vector<int> result;\n\n        for (int i = 0; i < nums.size(); ++i) {\n            // Remove indices from the front that are out of the window\n            if (!dq.empty() && dq.front() == i - k) {\n                dq.pop_front();\n            }\n            // Maintain decreasing order in deque\n            while (!dq.empty() && nums[dq.back()] < nums[i]) {\n                dq.pop_back();\n            }\n            dq.push_back(i);\n\n            // Add to result once the window is full\n            if (i >= k - 1) {\n                result.push_back(nums[dq.front()]);\n            }\n        }\n        return result;\n    }\n};\n```",
                    "python": "```python\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: list[int], k: int) -> list[int]:\n        dq = deque()  # Stores indices\n        result = []\n\n        for i in range(len(nums)):\n            # Remove indices from the left that are out of the window\n            if dq and dq[0] == i - k:\n                dq.popleft()\n            \n            # Maintain decreasing order in deque\n            while dq and nums[dq[-1]] < nums[i]:\n                dq.pop()\n            \n            dq.append(i)\n\n            # Add to result once the window is full\n            if i >= k - 1:\n                result.append(nums[dq[0]])\n        \n        return result\n```",
                    "javascript": "```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    const dq = []; // Stores indices\n    const result = [];\n\n    for (let i = 0; i < nums.length; i++) {\n        // Remove indices from the front that are out of the window\n        if (dq.length > 0 && dq[0] === i - k) {\n            dq.shift();\n        }\n        // Maintain decreasing order in deque\n        while (dq.length > 0 && nums[dq[dq.length - 1]] < nums[i]) {\n            dq.pop();\n        }\n        dq.push(i);\n\n        // Add to result once the window is full\n        if (i >= k - 1) {\n            result.push(nums[dq[0]]);\n        }\n    }\n    return result;\n};\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Queues are fundamental for **Breadth-First Search (BFS)**, which is a core traversal algorithm for trees and graphs. Any problem that involves 'level-order', 'shortest path in an unweighted graph', or processing items in their arrival order is a strong candidate for a queue.\n\n### Tips:\n- **Queue for BFS:** Remember this pairing: Queue -> BFS, Stack -> DFS. When you need to explore layer by layer, a queue is the tool.\n- **Choose the Right Implementation:** In languages like Python, `collections.deque` is highly optimized for O(1) appends and pops from both ends, making it a perfect choice for both queues and deques. In JavaScript, a simple array `shift()` is O(n), so for performance-critical queue operations, a custom implementation with a linked list or two pointers is better."
    },
    "Tree": {
        "topicName": "Tree",
        "theoryAndFeatures": "A **Tree** is a non-linear, hierarchical data structure consisting of nodes connected by edges. It is a type of graph with no cycles. The topmost node is the **root**. Each node can have zero or more child nodes.\n\n### Key Terminology:\n- **Node:** An entity containing a key or value and pointers to its child nodes.\n- **Edge:** The link between two nodes.\n- **Root:** The topmost node in a tree.\n- **Parent/Child:** A node that has an edge to another node is the parent; the node at the other end of the edge is the child.\n- **Leaf:** A node with no children.\n- **Depth of a node:** Length of the path from the root to the node.\n- **Height of a tree:** Length of the longest path from the root to a leaf.\n\n### Binary Trees:\nA tree where each node has at most two children, referred to as the left child and the right child. This is the most common type of tree in interviews.\n\n### Tree Traversal Algorithms:\n- **Depth-First Search (DFS):** Explores as far as possible along each branch before backtracking.\n  - **Pre-order:** Root -> Left -> Right\n  - **In-order:** Left -> Root -> Right (yields sorted data for a BST)\n  - **Post-order:** Left -> Right -> Root\n- **Breadth-First Search (BFS) / Level Order:** Explores all nodes at the present depth prior to moving on to the nodes at the next depth level. Uses a queue.\n\n### Complexity Analysis (for a balanced binary tree):\n| Operation         | Average Case | Worst Case   | Explanation                                                              |\n| ----------------- | ------------ | ------------ | ------------------------------------------------------------------------ |\n| Access / Search   | O(log n)     | O(n)         | Worst case occurs in a skewed (unbalanced) tree.                         |\n| Insertion         | O(log n)     | O(n)         | Depends on finding the place to insert.                                  |\n| Deletion          | O(log n)     | O(n)         | Depends on finding the node to delete.                                   |",
        "realWorldAnalogy": "A tree is like a **family tree** 🌳 or a company's **organizational chart**. There's a single ancestor or CEO at the top (the root), and the hierarchy flows downwards. Each person (node) is connected to their direct descendants (children).",
        "advancedTopics": "- **Binary Search Tree (BST):** A binary tree with a special property: a node's left subtree contains only nodes with keys lesser than the node's key, and its right subtree contains only nodes with keys greater than the node's key.\n- **Self-Balancing Trees (AVL, Red-Black Trees):** BSTs that automatically keep their height small, guaranteeing O(log n) performance for all operations.\n- **B-Tree:** A generalization of a BST used in databases and filesystems, where nodes can have more than two children.",
        "codingProblems": [
            {
                "title": "Maximum Depth of Binary Tree",
                "description": "Given the root of a binary tree, return its maximum depth.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
                    "gfg": "https://www.geeksforgeeks.org/problems/height-of-binary-tree/1"
                },
                "pattern": "Recursive Depth-First Search (DFS). The depth is 1 + max(depth of left child, depth of right child).",
                "solutions": {
                    "cpp": "```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode { ... };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        int leftDepth = maxDepth(root->left);\n        int rightDepth = maxDepth(root->right);\n        return 1 + std::max(leftDepth, rightDepth);\n    }\n};\n```",
                    "python": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        left_depth = self.maxDepth(root.left)\n        right_depth = self.maxDepth(root.right)\n        return 1 + max(left_depth, right_depth)\n```",
                    "javascript": "```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) { ... }\n */\nvar maxDepth = function(root) {\n    if (!root) {\n        return 0;\n    }\n    const leftDepth = maxDepth(root.left);\n    const rightDepth = maxDepth(root.right);\n    return 1 + Math.max(leftDepth, rightDepth);\n};\n```"
                }
            },
            {
                "title": "Binary Tree Level Order Traversal",
                "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
                "links": {
                    "leetCode": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
                    "gfg": "https://www.geeksforgeeks.org/problems/level-order-traversal/1"
                },
                "pattern": "Breadth-First Search (BFS) using a queue.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <queue>\n\nclass Solution {\npublic:\n    std::vector<std::vector<int>> levelOrder(TreeNode* root) {\n        std::vector<std::vector<int>> result;\n        if (!root) return result;\n        \n        std::queue<TreeNode*> q;\n        q.push(root);\n        \n        while (!q.empty()) {\n            int levelSize = q.size();\n            std::vector<int> currentLevel;\n            for (int i = 0; i < levelSize; ++i) {\n                TreeNode* node = q.front();\n                q.pop();\n                currentLevel.push_back(node->val);\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            result.push_back(currentLevel);\n        }\n        return result;\n    }\n};\n```",
                    "python": "```python\nfrom collections import deque\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> list[list[int]]:\n        if not root:\n            return []\n        \n        result = []\n        q = deque([root])\n        \n        while q:\n            level_size = len(q)\n            current_level = []\n            for _ in range(level_size):\n                node = q.popleft()\n                current_level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            result.append(current_level)\n        return result\n```",
                    "javascript": "```javascript\nvar levelOrder = function(root) {\n    if (!root) return [];\n    \n    const result = [];\n    const q = [root];\n    \n    while (q.length > 0) {\n        const levelSize = q.length;\n        const currentLevel = [];\n        for (let i = 0; i < levelSize; i++) {\n            const node = q.shift();\n            currentLevel.push(node.val);\n            if (node.left) q.push(node.left);\n            if (node.right) q.push(node.right);\n        }\n        result.push(currentLevel);\n    }\n    return result;\n};\n```"
                }
            },
            {
                "title": "Lowest Common Ancestor of a Binary Search Tree",
                "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
                    "gfg": "https://www.geeksforgeeks.org/problems/lowest-common-ancestor-in-a-bst/1"
                },
                "pattern": "Recursive or iterative traversal. Utilize the properties of a BST to decide whether to go left or right.",
                "solutions": {
                    "cpp": "```cpp\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (!root) return nullptr;\n\n        if (p->val > root->val && q->val > root->val) {\n            return lowestCommonAncestor(root->right, p, q);\n        } else if (p->val < root->val && q->val < root->val) {\n            return lowestCommonAncestor(root->left, p, q);\n        } else {\n            return root;\n        }\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        if not root:\n            return None\n        \n        if p.val > root.val and q.val > root.val:\n            return self.lowestCommonAncestor(root.right, p, q)\n        elif p.val < root.val and q.val < root.val:\n            return self.lowestCommonAncestor(root.left, p, q)\n        else:\n            return root\n```",
                    "javascript": "```javascript\nvar lowestCommonAncestor = function(root, p, q) {\n    if (!root) return null;\n\n    if (p.val > root.val && q.val > root.val) {\n        return lowestCommonAncestor(root.right, p, q);\n    } else if (p.val < root.val && q.val < root.val) {\n        return lowestCommonAncestor(root.left, p, q);\n    } else {\n        return root;\n    }\n};\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Trees are extremely important. Questions test your understanding of recursion and traversal algorithms (DFS/BFS). Binary Search Trees (BSTs) are particularly common because their properties allow for efficient solutions.\n\n### Tips:\n- **Recursion is Your Friend:** The vast majority of tree problems can be solved elegantly with recursion. Define a base case (usually an empty `root`) and then make recursive calls on the left and right children.\n- **DFS vs. BFS:** Use DFS (pre-order, in-order, post-order) when you need to explore a branch completely. Use BFS (level-order) for problems involving levels or finding the shortest path in terms of number of edges."
    },
    "Graph": {
        "topicName": "Graph",
        "theoryAndFeatures": "A **Graph** is a non-linear data structure consisting of a finite set of **vertices** (or nodes) and a set of **edges** connecting these vertices. It's a versatile structure used to model relationships.\n\n### Key Concepts:\n- **Vertex:** A node in the graph.\n- **Edge:** A connection between two vertices.\n- **Directed vs. Undirected:** In an undirected graph, an edge (A, B) is the same as (B, A). In a directed graph, the connection has a direction (A -> B).\n- **Weighted vs. Unweighted:** Edges can have weights, representing a cost or distance.\n\n### Representations:\n- **Adjacency Matrix:** A 2D array where `matrix[i][j] = 1` if an edge exists between vertex `i` and `j`. Uses O(V²) space. Fast to check for an edge between two nodes.\n- **Adjacency List:** An array where each index `i` stores a list of vertices adjacent to vertex `i`. Uses O(V+E) space. Most common and efficient representation for sparse graphs.\n\n### Traversal Algorithms:\n- **Breadth-First Search (BFS):** Explores neighbors level by level using a queue. Finds the shortest path in an unweighted graph.\n- **Depth-First Search (DFS):** Explores as far as possible along each branch before backtracking, using recursion or a stack.\n\n### Complexity Analysis (Adjacency List):\n| Operation         | Time Complexity | Space Complexity |\n| ----------------- | --------------- | ---------------- |\n| Add Vertex        | O(1)            | O(V+E)           |\n| Add Edge          | O(1)            | O(V+E)           |\n| BFS / DFS         | O(V+E)          | O(V)             |",
        "realWorldAnalogy": "A graph is like a **city map** 🗺️. Cities are vertices, and the roads connecting them are edges. The roads can be one-way (directed) and have distances (weighted). Another great example is a **social network**, where people are vertices and friendships are edges.",
        "advancedTopics": "- **Topological Sort:** An ordering of vertices in a Directed Acyclic Graph (DAG) such that for every directed edge from vertex U to vertex V, U comes before V in the ordering.\n- **Minimum Spanning Tree (MST):** A subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. (Algorithms: Kruskal's, Prim's).\n- **Shortest Path Algorithms:** Algorithms to find the shortest path between nodes in a weighted graph. (Algorithms: Dijkstra's, Bellman-Ford, A*).",
        "codingProblems": [
            {
                "title": "Clone Graph",
                "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/clone-graph/",
                    "gfg": "https://www.geeksforgeeks.org/problems/clone-graph/1"
                },
                "pattern": "Graph traversal (DFS or BFS) with a hash map to store visited/cloned nodes to avoid infinite loops and redundant work.",
                "solutions": {
                    "cpp": "```cpp\n/*\n// Definition for a Node.\nclass Node { ... };\n*/\n#include <unordered_map>\n\nclass Solution {\npublic:\n    std::unordered_map<Node*, Node*> visited;\n    Node* cloneGraph(Node* node) {\n        if (!node) return nullptr;\n        if (visited.count(node)) {\n            return visited[node];\n        }\n\n        Node* clone = new Node(node->val);\n        visited[node] = clone;\n\n        for (Node* neighbor : node->neighbors) {\n            clone->neighbors.push_back(cloneGraph(neighbor));\n        }\n        return clone;\n    }\n};\n```",
                    "python": "```python\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\nclass Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        if not node:\n            return None\n        \n        visited = {}\n\n        def dfs(original_node):\n            if original_node in visited:\n                return visited[original_node]\n            \n            clone_node = Node(original_node.val)\n            visited[original_node] = clone_node\n\n            for neighbor in original_node.neighbors:\n                clone_node.neighbors.append(dfs(neighbor))\n            \n            return clone_node\n        \n        return dfs(node)\n```",
                    "javascript": "```javascript\n/**\n * // Definition for a Node.\n * function Node(val, neighbors) { ... };\n */\nvar cloneGraph = function(node) {\n    const visited = new Map();\n\n    function dfs(originalNode) {\n        if (!originalNode) return null;\n        if (visited.has(originalNode)) {\n            return visited.get(originalNode);\n        }\n\n        const cloneNode = new Node(originalNode.val);\n        visited.set(originalNode, cloneNode);\n\n        for (const neighbor of originalNode.neighbors) {\n            cloneNode.neighbors.push(dfs(neighbor));\n        }\n        return cloneNode;\n    }\n\n    return dfs(node);\n};\n```"
                }
            },
            {
                "title": "Course Schedule",
                "description": "There are a total of `numCourses` courses you have to take, labeled from 0 to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`. Return `true` if you can finish all courses. Otherwise, return `false`.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/course-schedule/",
                    "gfg": "https://www.geeksforgeeks.org/problems/course-schedule/1"
                },
                "pattern": "Cycle detection in a directed graph. This can be solved with DFS or with a topological sort approach (Kahn's Algorithm using a queue).",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n\nclass Solution {\npublic:\n    bool canFinish(int numCourses, std::vector<std::vector<int>>& prerequisites) {\n        std::vector<std::vector<int>> adj(numCourses);\n        std::vector<int> in_degree(numCourses, 0);\n        for (const auto& p : prerequisites) {\n            adj[p[1]].push_back(p[0]);\n            in_degree[p[0]]++;\n        }\n\n        std::queue<int> q;\n        for (int i = 0; i < numCourses; ++i) {\n            if (in_degree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int count = 0;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            count++;\n            for (int v : adj[u]) {\n                if (--in_degree[v] == 0) {\n                    q.push(v);\n                }\n            }\n        }\n        return count == numCourses;\n    }\n};\n```",
                    "python": "```python\nfrom collections import deque, defaultdict\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:\n        adj = defaultdict(list)\n        in_degree = [0] * numCourses\n\n        for course, prereq in prerequisites:\n            adj[prereq].append(course)\n            in_degree[course] += 1\n\n        q = deque([i for i in range(numCourses) if in_degree[i] == 0])\n        count = 0\n\n        while q:\n            u = q.popleft()\n            count += 1\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    q.append(v)\n        \n        return count == numCourses\n```",
                    "javascript": "```javascript\nvar canFinish = function(numCourses, prerequisites) {\n    const adj = Array(numCourses).fill(0).map(() => []);\n    const inDegree = Array(numCourses).fill(0);\n\n    for (const [course, prereq] of prerequisites) {\n        adj[prereq].push(course);\n        inDegree[course]++;\n    }\n\n    const q = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (inDegree[i] === 0) {\n            q.push(i);\n        }\n    }\n\n    let count = 0;\n    while (q.length > 0) {\n        const u = q.shift();\n        count++;\n        for (const v of adj[u]) {\n            inDegree[v]--;\n            if (inDegree[v] === 0) {\n                q.push(v);\n            }\n        }\n    }\n\n    return count === numCourses;\n};\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Graph problems are common in interviews for mid-to-senior level roles. They test your ability to model a problem and apply standard traversal algorithms. Many problems that don't seem like graph problems can be modeled as one (e.g., word ladder, course scheduling).\n\n### Tips:\n- **Choose the Right Representation:** For most interview problems, an adjacency list is the way to go because graphs are often sparse.\n- **Track Visited Nodes:** This is the most crucial part of any graph traversal. Forgetting to mark nodes as visited will almost certainly lead to an infinite loop if the graph has cycles. Use a hash set or a boolean array for this."
    },
    "Heap": {
        "topicName": "Heap (Priority Queue)",
        "theoryAndFeatures": "A **Heap** is a specialized tree-based data structure that satisfies the **heap property**. It is a **complete binary tree**, which allows it to be efficiently implemented using an array.\n\n### Key Concepts:\n- **Heap Property:**\n  - **Min-Heap:** The value of each node is less than or equal to the value of its children. The root is the minimum element.\n  - **Max-Heap:** The value of each node is greater than or equal to the value of its children. The root is the maximum element.\n- **Complete Binary Tree:** A binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.\n- **Priority Queue:** A Heap is the perfect data structure for implementing a Priority Queue, where you need to efficiently find and extract the element with the highest (or lowest) priority.\n\n### Complexity Analysis:\n| Operation         | Time Complexity | Explanation                                                              |\n| ----------------- | --------------- | ------------------------------------------------------------------------ |\n| Insert (push)     | O(log n)        | The new element is added to the end and then 'sifted up' to its correct position. |\n| Extract Min/Max   | O(log n)        | The root is removed, the last element is moved to the root, and then 'sifted down'. |\n| Peek Min/Max      | O(1)            | The min/max element is always at the root.                                 |",
        "realWorldAnalogy": "A heap is like a hospital **emergency room triage** 🏥. Patients (elements) aren't treated in the order they arrive (FIFO). Instead, the most critical patient (highest priority/min or max value) is always treated next. When a new, more critical patient arrives, they 'jump the queue' and are moved to the front.",
        "advancedTopics": "- **Heapsort:** A comparison-based sorting algorithm that uses a heap to sort an array in O(n log n) time with O(1) space.\n- **d-ary Heap:** A generalization of a binary heap where nodes have `d` children instead of 2.\n- **Fibonacci Heap:** A more complex heap structure that provides better amortized running time for some operations, used in advanced algorithms like Dijkstra's.",
        "codingProblems": [
            {
                "title": "Kth Largest Element in an Array",
                "description": "Given an integer array `nums` and an integer `k`, return the `k`th largest element in the array.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
                    "gfg": "https://www.geeksforgeeks.org/problems/kth-smallest-element5635/1"
                },
                "pattern": "Use a Min-Heap of size `k`. Iterate through the array, adding elements to the heap. If the heap size exceeds `k`, pop the smallest element. The root of the heap will be the Kth largest element.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <queue>\n#include <functional>\n\nclass Solution {\npublic:\n    int findKthLargest(std::vector<int>& nums, int k) {\n        std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n        for (int num : nums) {\n            minHeap.push(num);\n            if (minHeap.size() > k) {\n                minHeap.pop();\n            }\n        }\n        return minHeap.top();\n    }\n};\n```",
                    "python": "```python\nimport heapq\n\nclass Solution:\n    def findKthLargest(self, nums: list[int], k: int) -> int:\n        min_heap = []\n        for num in nums:\n            heapq.heappush(min_heap, num)\n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n        return min_heap[0]\n```",
                    "javascript": "```javascript\n// JavaScript doesn't have a built-in heap/priority queue.\n// A common approach in interviews is to sort (O(N log N)) or explain the heap approach.\nvar findKthLargest = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    return nums[nums.length - k];\n};\n// To solve this optimally in JS, you would need to implement a Min-Heap class.\n```"
                }
            },
            {
                "title": "Find Median from Data Stream",
                "description": "The median is the middle value in an ordered integer list. Design a data structure that supports adding numbers from a data stream and finding the median.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/find-median-from-data-stream/",
                    "gfg": "https://www.geeksforgeeks.org/problems/find-median-in-a-stream-1587115620/1"
                },
                "pattern": "Two Heaps. Use a Max-Heap to store the smaller half of the numbers and a Min-Heap to store the larger half. Keep the heaps balanced.",
                "solutions": {
                    "cpp": "```cpp\n#include <queue>\n#include <vector>\n\nclass MedianFinder {\n    std::priority_queue<int> max_heap; // smaller half\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap; // larger half\npublic:\n    MedianFinder() {}\n    \n    void addNum(int num) {\n        max_heap.push(num);\n        min_heap.push(max_heap.top());\n        max_heap.pop();\n        \n        if (min_heap.size() > max_heap.size()) {\n            max_heap.push(min_heap.top());\n            min_heap.pop();\n        }\n    }\n    \n    double findMedian() {\n        if (max_heap.size() > min_heap.size()) {\n            return max_heap.top();\n        } else {\n            return (max_heap.top() + min_heap.top()) / 2.0;\n        }\n    }\n};\n```",
                    "python": "```python\nimport heapq\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.small_half = []  # max-heap (implemented with negative numbers in a min-heap)\n        self.large_half = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small_half, -1 * num)\n        \n        # Ensure every element in small_half is <= every element in large_half\n        if self.small_half and self.large_half and (-1 * self.small_half[0]) > self.large_half[0]:\n            val = -1 * heapq.heappop(self.small_half)\n            heapq.heappush(self.large_half, val)\n        \n        # Balance the heaps\n        if len(self.small_half) > len(self.large_half) + 1:\n            val = -1 * heapq.heappop(self.small_half)\n            heapq.heappush(self.large_half, val)\n        if len(self.large_half) > len(self.small_half):\n            val = heapq.heappop(self.large_half)\n            heapq.heappush(self.small_half, -1 * val)\n\n    def findMedian(self) -> float:\n        if len(self.small_half) > len(self.large_half):\n            return -1 * self.small_half[0]\n        return (-1 * self.small_half[0] + self.large_half[0]) / 2.0\n```",
                    "javascript": "```javascript\n// JavaScript does not have a built-in Heap. This problem is very difficult\n// to solve optimally in an interview without a pre-existing Heap library.\n// One would typically be expected to implement a Heap class first.\nclass MedianFinder {\n    // Implementation requires a custom MaxHeap and MinHeap class.\n}\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Heap (Priority Queue) questions are very popular. They are the go-to data structure for any problem that involves finding the 'top/smallest/largest K' elements, or scheduling tasks based on priority. The 'Median from Data Stream' problem is a classic hard question that really tests your understanding.\n\n### Tips:\n- **Know Your Library:** Be familiar with your language's priority queue or heap implementation. Know if it's a min-heap or max-heap by default and how to change it (e.g., in C++ with `std::greater`, or in Python by storing negative numbers).\n- **Identify the Pattern:** When you read phrases like 'most frequent', 'top K', 'minimum cost to connect', think 'Heap'."
    },
    "Trie": {
        "topicName": "Trie (Prefix Tree)",
        "theoryAndFeatures": "A **Trie**, also known as a **Prefix Tree**, is a tree-like data structure that stores a dynamic set of strings. Each node in the Trie represents a single character. A path from the root to a node represents a prefix, and if a node is marked as a terminal node (end of word), that path represents a complete word in the set.\n\n### Key Features:\n- **Efficient Prefix Searching:** Tries excel at operations like prefix matching and auto-completion. Looking up a word of length `L` takes O(L) time, independent of the number of words in the Trie.\n- **Structure:** Each node typically contains an array/map of pointers (one for each possible character in the alphabet) to its children and a boolean flag indicating if it's the end of a word.\n\n### Complexity Analysis (L = length of the word, N = number of words):\n| Operation         | Time Complexity | Space Complexity |\n| ----------------- | --------------- | ---------------- |\n| Insert            | O(L)            | O(N * L)         |\n| Search            | O(L)            | O(N * L)         |\n| Starts With       | O(L)            | O(N * L)         |",
        "realWorldAnalogy": "A Trie is like an **autocomplete system** on your phone or in a search engine. As you type 'inter', it instantly suggests 'interview', 'international', 'internet'. It does this by traversing a path in a Trie for the prefix 'inter' and then finding all the words that continue from that point.",
        "advancedTopics": "- **Compressed Trie (Radix Tree):** A space-optimized Trie where nodes with only one child are merged to save space.\n- **Ternary Search Tree:** A hybrid between a binary search tree and a Trie, which can be more space-efficient.",
        "codingProblems": [
            {
                "title": "Implement Trie (Prefix Tree)",
                "description": "Implement a Trie with `insert`, `search`, and `startsWith` methods.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/implement-trie-prefix-tree/",
                    "gfg": "https://www.geeksforgeeks.org/problems/trie-insert-and-search/1"
                },
                "pattern": "Standard Trie implementation using a Node class that contains a children map/array and an end-of-word flag.",
                "solutions": {
                    "cpp": "```cpp\n#include <string>\n#include <unordered_map>\n\nclass TrieNode {\npublic:\n    std::unordered_map<char, TrieNode*> children;\n    bool isEndOfWord;\n    TrieNode() : isEndOfWord(false) {}\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\npublic:\n    Trie() { root = new TrieNode(); }\n    \n    void insert(std::string word) {\n        TrieNode* current = root;\n        for (char ch : word) {\n            if (current->children.find(ch) == current->children.end()) {\n                current->children[ch] = new TrieNode();\n            }\n            current = current->children[ch];\n        }\n        current->isEndOfWord = true;\n    }\n    \n    bool search(std::string word) {\n        TrieNode* current = root;\n        for (char ch : word) {\n            if (current->children.find(ch) == current->children.end()) {\n                return false;\n            }\n            current = current->children[ch];\n        }\n        return current->isEndOfWord;\n    }\n    \n    bool startsWith(std::string prefix) {\n        TrieNode* current = root;\n        for (char ch : prefix) {\n            if (current->children.find(ch) == current->children.end()) {\n                return false;\n            }\n            current = current->children[ch];\n        }\n        return true;\n    }\n};\n```",
                    "python": "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                current.children[char] = TrieNode()\n            current = current.children[char]\n        current.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                return False\n            current = current.children[char]\n        return current.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        current = self.root\n        for char in prefix:\n            if char not in current.children:\n                return False\n            current = current.children[char]\n        return True\n```",
                    "javascript": "```javascript\nclass TrieNode {\n    constructor() {\n        this.children = {};\n        this.isEndOfWord = false;\n    }\n}\n\nclass Trie {\n    constructor() {\n        this.root = new TrieNode();\n    }\n\n    insert(word) {\n        let current = this.root;\n        for (const char of word) {\n            if (!current.children[char]) {\n                current.children[char] = new TrieNode();\n            }\n            current = current.children[char];\n        }\n        current.isEndOfWord = true;\n    }\n\n    search(word) {\n        let current = this.root;\n        for (const char of word) {\n            if (!current.children[char]) {\n                return false;\n            }\n            current = current.children[char];\n        }\n        return current.isEndOfWord;\n    }\n\n    startsWith(prefix) {\n        let current = this.root;\n        for (const char of prefix) {\n            if (!current.children[char]) {\n                return false;\n            }\n            current = current.children[char];\n        }\n        return true;\n    }\n}\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Tries are a specialized but important data structure. If you see a problem involving a dictionary of words, prefix matching, or auto-completion, a Trie is very likely the intended optimal solution. Knowing how to implement one from scratch is often expected.\n\n### Tips:\n- **Map vs. Array:** In your TrieNode, you can use a hash map for children (more flexible for any character set) or a fixed-size array (faster, but limited to a known character set like lowercase English letters)."
    },
    "DynamicProgramming": {
        "topicName": "Dynamic Programming (DP)",
        "theoryAndFeatures": "Dynamic Programming is a powerful algorithmic technique for solving optimization problems by breaking them down into simpler, overlapping subproblems. It solves each subproblem only once and stores its solution, avoiding redundant computations.\n\n### Key Properties for DP:\n1.  **Optimal Substructure:** The optimal solution to the main problem can be constructed from the optimal solutions of its subproblems.\n2.  **Overlapping Subproblems:** The algorithm recomputes the same subproblems over and over again if not for memoization.\n\n### Two Main Approaches:\n- **Memoization (Top-Down):** A recursive approach where you solve the problem by breaking it down. Store the results of subproblems in a cache (memo) so you don't have to recompute them.\n- **Tabulation (Bottom-Up):** An iterative approach where you solve the problem from the smallest possible subproblem and build up to the final solution, typically by filling out a table (e.g., a DP array).\n\nThis is an algorithmic paradigm, not a data structure.",
        "realWorldAnalogy": "Dynamic Programming is like calculating the **fastest route on a map with many intermediate stops**. Instead of re-calculating the fastest way from the start to Stop B every time you plan a route that passes through it, you calculate it once, write it down (memoization), and reuse that result whenever needed. You build up the optimal solution from smaller, known optimal solutions.",
        "advancedTopics": "- **DP on Grids:** Common problems involving finding paths in a grid (e.g., Unique Paths).\n- **Knapsack Problem:** A classic DP problem (0/1 Knapsack, Unbounded Knapsack).\n- **Longest Common Subsequence (LCS):** A foundational DP problem with applications in bioinformatics and file comparison.\n- **DP with Bitmasking:** Used to solve problems with states that can be represented by a bitmask, typically when N is small (e.g., <= 20).",
        "codingProblems": [
            {
                "title": "Climbing Stairs",
                "description": "You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
                "links": {
                    "leetCode": "https://leetcode.com/problems/climbing-stairs/",
                    "gfg": "https://www.geeksforgeeks.org/problems/count-ways-to-reach-the-nth-stair-1587115620/1"
                },
                "pattern": "Fibonacci-style DP. The number of ways to reach step `n` is `ways(n-1) + ways(n-2)`.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n\nclass Solution {\npublic:\n    // Tabulation (Bottom-Up) approach\n    int climbStairs(int n) {\n        if (n <= 2) return n;\n        std::vector<int> dp(n + 1);\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; ++i) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    # Tabulation (Bottom-Up) with space optimization\n    def climbStairs(self, n: int) -> int:\n        if n <= 2:\n            return n\n        one_step_before, two_steps_before = 2, 1\n        for _ in range(3, n + 1):\n            current = one_step_before + two_steps_before\n            two_steps_before = one_step_before\n            one_step_before = current\n        return one_step_before\n```",
                    "javascript": "```javascript\n/**\n * @param {number} n\n * @return {number}\n */\n// Tabulation (Bottom-Up) approach\nvar climbStairs = function(n) {\n    if (n <= 2) return n;\n    const dp = new Array(n + 1);\n    dp[1] = 1;\n    dp[2] = 2;\n    for (let i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n};\n```"
                }
            },
            {
                "title": "Coin Change",
                "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount`. Return the fewest number of coins that you need to make up that amount.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/coin-change/",
                    "gfg": "https://www.geeksforgeeks.org/problems/coin-change2050/1"
                },
                "pattern": "Bottom-up DP. `dp[i]` stores the minimum coins needed for amount `i`.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int coinChange(std::vector<int>& coins, int amount) {\n        std::vector<int> dp(amount + 1, amount + 1);\n        dp[0] = 0;\n\n        for (int i = 1; i <= amount; ++i) {\n            for (int coin : coins) {\n                if (i - coin >= 0) {\n                    dp[i] = std::min(dp[i], 1 + dp[i - coin]);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def coinChange(self, coins: list[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for i in range(1, amount + 1):\n            for coin in coins:\n                if i - coin >= 0:\n                    dp[i] = min(dp[i], 1 + dp[i - coin])\n        \n        return dp[amount] if dp[amount] != float('inf') else -1\n```",
                    "javascript": "```javascript\nvar coinChange = function(coins, amount) {\n    const dp = new Array(amount + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for (let i = 1; i <= amount; i++) {\n        for (const coin of coins) {\n            if (i - coin >= 0) {\n                dp[i] = Math.min(dp[i], 1 + dp[i - coin]);\n            }\n        }\n    }\n\n    return dp[amount] === Infinity ? -1 : dp[amount];\n};\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** DP is a very common topic in interviews for top tech companies, often appearing in medium to hard problems. It's considered a benchmark for strong problem-solving skills. Recognizing that a problem can be solved with DP is the hardest part.\n\n### Tips:\n- **Identify DP:** Look for keywords like 'minimum', 'maximum', 'number of ways', 'longest'. If you can define a state and a recurrence relation (how to get from one state to another), it's likely a DP problem.\n- **Start with Recursion:** If you're struggling, first write a brute-force recursive solution. Then, add a memoization cache to optimize it. This top-down approach is often more intuitive than jumping straight to a bottom-up table."
    },
    "Greedy": {
        "topicName": "Greedy Algorithms",
        "theoryAndFeatures": "A **Greedy Algorithm** is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit. It makes a **locally optimal choice** at each stage with the hope of finding a global optimum.\n\n### Key Features:\n- **Locally Optimal Choices:** The core idea is to make the best possible choice at the current moment without considering future consequences.\n- **Not Always Optimal:** For many problems, a greedy strategy does not produce an optimal solution (e.g., the coin change problem with certain coin denominations).\n- **Proof of Correctness:** The main challenge is proving that the locally optimal choices will lead to a globally optimal solution.\n\nThis is an algorithmic paradigm, not a data structure.",
        "realWorldAnalogy": "A greedy algorithm is like **giving change with the fewest coins**. To give 48 cents in change, you greedily pick the largest coin possible that isn't too large: first a quarter (25), then a dime (10), then another dime (10), then three pennies (1, 1, 1). At each step, you make the locally optimal choice of picking the largest coin, which in this case leads to the global optimum.",
        "advancedTopics": "- **Activity Selection Problem:** A classic greedy problem.\n- **Huffman Coding:** A famous greedy algorithm used for data compression.\n- **Kruskal's and Prim's Algorithms:** Both are greedy algorithms for finding a Minimum Spanning Tree in a graph.",
        "codingProblems": [
            {
                "title": "Best Time to Buy and Sell Stock",
                "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`th day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
                    "gfg": "https://www.geeksforgeeks.org/problems/stock-buy-and-sell-1587115621/1"
                },
                "pattern": "Greedy. Iterate through the prices, keeping track of the minimum price seen so far. At each step, calculate the potential profit if you sold today and update the maximum profit.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int maxProfit(std::vector<int>& prices) {\n        int min_price = INT_MAX;\n        int max_profit = 0;\n        for (int price : prices) {\n            min_price = std::min(min_price, price);\n            max_profit = std::max(max_profit, price - min_price);\n        }\n        return max_profit;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def maxProfit(self, prices: list[int]) -> int:\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit\n```",
                    "javascript": "```javascript\nvar maxProfit = function(prices) {\n    let minPrice = Infinity;\n    let maxProfit = 0;\n    for (const price of prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n};\n```"
                }
            },
            {
                "title": "Jump Game",
                "description": "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return `true` if you can reach the last index, or `false` otherwise.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/jump-game/",
                    "gfg": "https://www.geeksforgeeks.org/problems/jump-game/1"
                },
                "pattern": "Greedy. Keep track of the maximum reachable index. At each step, update this maximum. If the current index ever exceeds the maximum reachable, you are stuck.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    bool canJump(std::vector<int>& nums) {\n        int max_reachable = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (i > max_reachable) {\n                return false;\n            }\n            max_reachable = std::max(max_reachable, i + nums[i]);\n            if (max_reachable >= nums.size() - 1) {\n                return true;\n            }\n        }\n        return true;\n    }\n};\n```",
                    "python": "```python\nclass Solution:\n    def canJump(self, nums: list[int]) -> bool:\n        max_reachable = 0\n        for i, num in enumerate(nums):\n            if i > max_reachable:\n                return False\n            max_reachable = max(max_reachable, i + num)\n            if max_reachable >= len(nums) - 1:\n                return True\n        return True\n```",
                    "javascript": "```javascript\nvar canJump = function(nums) {\n    let maxReachable = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (i > maxReachable) {\n            return false;\n        }\n        maxReachable = Math.max(maxReachable, i + nums[i]);\n        if (maxReachable >= nums.length - 1) {\n            return true;\n        }\n    }\n    return true;\n};\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Greedy algorithms appear often. They can seem deceptively simple, but the hard part is recognizing the pattern and being able to reason about *why* the greedy choice works. Problems that involve optimization and sorting are good candidates for a greedy approach.\n\n### Tips:\n- **Greedy vs. DP:** Many problems can be framed as either greedy or DP. If you can prove that making the locally optimal choice is always correct, use a greedy algorithm (it's usually simpler and faster). If you need to check multiple choices at each step, you probably need DP.\n- **Sort First:** A very common pattern in greedy problems is to sort the input first. This often sets up the data in a way that makes the greedy choice obvious (e.g., Merge Intervals, Activity Selection)."
    },
    "SegmentTree": {
        "topicName": "Segment Tree",
        "theoryAndFeatures": "A **Segment Tree** is a versatile, tree-based data structure used for storing information about intervals or segments. It is a full binary tree that allows for efficient **range queries** and **point updates** on an array.\n\n### Key Concepts:\n- **Structure:** Each node in the segment tree represents an interval of the original array. The root represents the entire array `[0, n-1]`. Each internal node stores some aggregate information (like sum, min, max, or gcd) of its children's intervals. Leaf nodes represent individual elements of the array.\n- **Use Case:** It is extremely useful when you have an array that is modified frequently, and you need to perform many range queries.\n\n### Complexity Analysis:\n| Operation         | Time Complexity | Explanation                                                              |\n| ----------------- | --------------- | ------------------------------------------------------------------------ |\n| Build Tree        | O(n)            | The tree has roughly 2n nodes, and each is visited once during construction. |\n| Range Query       | O(log n)        | The query path goes down the tree, which has a height of log n.          |\n| Point Update      | O(log n)        | The update path also goes down the tree to a leaf and then back up.      |",
        "realWorldAnalogy": "A segment tree is like a **company's reporting hierarchy**. A store manager (leaf node) knows their individual store's sales. A regional manager (internal node) knows the total sales for all stores in their region by summing up the reports from their store managers. The CEO (root node) knows the total company sales by summing up the reports from all regional managers. If one store updates its sales, only the managers directly above it need to update their totals, not the entire company.",
        "advancedTopics": "- **Lazy Propagation:** An optimization technique for performing range updates (e.g., add a value to every element in a range `[i, j]`) in O(log n) time instead of O(n).\n- **2D Segment Trees:** Can be used to perform queries over a 2D matrix.\n- **Persistent Segment Trees:** A version of the data structure where every update creates a new version of the tree, allowing for queries on previous states.",
        "codingProblems": [
            {
                "title": "Range Sum Query - Mutable",
                "description": "Given an integer array `nums`, handle two types of queries: 1. Update the value of an element in `nums`. 2. Calculate the sum of the elements of `nums` between indices `left` and `right` inclusive.",
                "links": {
                    "leetCode": "https://leetcode.com/problems/range-sum-query-mutable/",
                    "gfg": "https://www.geeksforgeeks.org/problems/range-sum-queries/1"
                },
                "pattern": "Standard Segment Tree implementation for range sum queries and point updates.",
                "solutions": {
                    "cpp": "```cpp\n#include <vector>\n\nclass NumArray {\nprivate:\n    std::vector<int> tree;\n    int n;\n\n    void build(const std::vector<int>& nums, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = nums[start];\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        build(nums, 2 * node + 1, start, mid);\n        build(nums, 2 * node + 2, mid + 1, end);\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\n    void updateTree(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            tree[node] = val;\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        if (start <= idx && idx <= mid) {\n            updateTree(2 * node + 1, start, mid, idx, val);\n        } else {\n            updateTree(2 * node + 2, mid + 1, end, idx, val);\n        }\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\n    int queryTree(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return 0;\n        }\n        if (l <= start && end <= r) {\n            return tree[node];\n        }\n        int mid = start + (end - start) / 2;\n        int p1 = queryTree(2 * node + 1, start, mid, l, r);\n        int p2 = queryTree(2 * node + 2, mid + 1, end, l, r);\n        return p1 + p2;\n    }\n\npublic:\n    NumArray(std::vector<int>& nums) {\n        n = nums.size();\n        tree.resize(4 * n);\n        build(nums, 0, 0, n - 1);\n    }\n    \n    void update(int index, int val) {\n        updateTree(0, 0, n - 1, index, val);\n    }\n    \n    int sumRange(int left, int right) {\n        return queryTree(0, 0, n - 1, left, right);\n    }\n};\n```",
                    "python": "```python\nclass NumArray:\n    def __init__(self, nums: list[int]):\n        self.n = len(nums)\n        self.tree = [0] * (4 * self.n)\n        self._build(nums, 0, 0, self.n - 1)\n\n    def _build(self, nums, node, start, end):\n        if start == end:\n            self.tree[node] = nums[start]\n            return\n        mid = (start + end) // 2\n        self._build(nums, 2 * node + 1, start, mid)\n        self._build(nums, 2 * node + 2, mid + 1, end)\n        self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update(self, index: int, val: int) -> None:\n        self._update_tree(0, 0, self.n - 1, index, val)\n\n    def _update_tree(self, node, start, end, idx, val):\n        if start == end:\n            self.tree[node] = val\n            return\n        mid = (start + end) // 2\n        if start <= idx <= mid:\n            self._update_tree(2 * node + 1, start, mid, idx, val)\n        else:\n            self._update_tree(2 * node + 2, mid + 1, end, idx, val)\n        self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self._query_tree(0, 0, self.n - 1, left, right)\n\n    def _query_tree(self, node, start, end, l, r):\n        if r < start or end < l:\n            return 0\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        p1 = self._query_tree(2 * node + 1, start, mid, l, r)\n        p2 = self._query_tree(2 * node + 2, mid + 1, end, l, r)\n        return p1 + p2\n```",
                    "javascript": "```javascript\nclass NumArray {\n    constructor(nums) {\n        this.n = nums.length;\n        this.tree = new Array(4 * this.n).fill(0);\n        this.build(nums, 0, 0, this.n - 1);\n    }\n\n    build(nums, node, start, end) {\n        if (start === end) {\n            this.tree[node] = nums[start];\n            return;\n        }\n        const mid = Math.floor(start + (end - start) / 2);\n        this.build(nums, 2 * node + 1, start, mid);\n        this.build(nums, 2 * node + 2, mid + 1, end);\n        this.tree[node] = this.tree[2 * node + 1] + this.tree[2 * node + 2];\n    }\n\n    update(index, val) {\n        this.updateTree(0, 0, this.n - 1, index, val);\n    }\n\n    updateTree(node, start, end, idx, val) {\n        if (start === end) {\n            this.tree[node] = val;\n            return;\n        }\n        const mid = Math.floor(start + (end - start) / 2);\n        if (start <= idx && idx <= mid) {\n            this.updateTree(2 * node + 1, start, mid, idx, val);\n        } else {\n            this.updateTree(2 * node + 2, mid + 1, end, idx, val);\n        }\n        this.tree[node] = this.tree[2 * node + 1] + this.tree[2 * node + 2];\n    }\n\n    sumRange(left, right) {\n        return this.queryTree(0, 0, this.n - 1, left, right);\n    }\n\n    queryTree(node, start, end, l, r) {\n        if (r < start || end < l) {\n            return 0;\n        }\n        if (l <= start && end <= r) {\n            return this.tree[node];\n        }\n        const mid = Math.floor(start + (end - start) / 2);\n        const p1 = this.queryTree(2 * node + 1, start, mid, l, r);\n        const p2 = this.queryTree(2 * node + 2, mid + 1, end, l, r);\n        return p1 + p2;\n    }\n}\n```"
                }
            }
        ],
        "extraInsights": "💡 **Interview Relevance:** Segment Trees are an advanced topic, typically only seen in difficult interview problems or competitive programming. You are unlikely to encounter them in a standard junior/mid-level interview, but they are good to know for senior roles or at companies with a strong algorithms focus. Simply knowing what they are and when they are used (frequent range queries and updates) is often enough.\n\n### Tips:\n- **Understand the Structure:** The key is to understand how the array indices map to nodes in the tree. A node `i` typically has children at `2*i+1` and `2*i+2`. Getting the recursive logic for `build`, `update`, and `query` correct is the main challenge."
    }
}
export default dsaData